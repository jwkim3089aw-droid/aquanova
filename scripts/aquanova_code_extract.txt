=========================================================
 AquaNova Source Code Extraction
 Generated: <built-in function times>
=========================================================



# [SKIP] Binary file excluded: NotoSans-Variable.ttf
------------------------------------------------------------


================================================================================
 FILE: api.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\api\v1\api.py
 TYPE: Python Code (Internal)
================================================================================

# app/api/v1/api.py
from fastapi import APIRouter

# Í∞Å Î™®ÎìàÏùò ÎùºÏö∞ÌÑ∞ ÏûÑÌè¨Ìä∏
from app.api.v1.health import router as health_router
from app.api.v1.simulation import router as simulation_router
from app.api.v1.user_settings import router as usersettings_router
from app.api.v1.reports import router as reports_router
from app.api.v1.hrro import router as hrro_router
from app.api.v1.routers import membranes as membranes_router

# ÌÜµÌï© ÎùºÏö∞ÌÑ∞ ÏÉùÏÑ±
api_router = APIRouter()

# --- ÎùºÏö∞ÌÑ∞ Îì±Î°ù (Ïó¨Í∏∞ÏÑú ÌïòÏúÑ Í≤ΩÎ°ú ÏßÄÏ†ï) ---

# 1. Health (Î≥¥ÌÜµ /health)
api_router.include_router(health_router, tags=["health"]) 

# 2. Simulation (/simulations)
api_router.include_router(simulation_router, prefix="/simulations", tags=["Simulation"])

# 3. User Settings (/user-settings)
api_router.include_router(usersettings_router, prefix="/user-settings", tags=["Settings"])

# 4. Reports (/reports)
api_router.include_router(reports_router, prefix="/reports", tags=["Reports"])

# 5. HRRO (/HRRO) -> ‚òÖ Ïó¨Í∏∞Í∞Ä ÌïµÏã¨ÏûÖÎãàÎã§
api_router.include_router(hrro_router, prefix="/HRRO", tags=["HRRO"])

# 6. Membranes (/membranes)
api_router.include_router(membranes_router.router, prefix="/membranes", tags=["Membranes"])

================================================================================
 FILE: health.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\api\v1\health.py
 TYPE: Python Code (Internal)
================================================================================

# ./app/api/v1/health.py
from __future__ import annotations
from fastapi import APIRouter
from pydantic import BaseModel
import redis
from rq import Queue
from app.core.config import settings

router = APIRouter(prefix="/health", tags=["health"])

class HealthOut(BaseModel):
    status: str
    env: str
    redis_ping: bool | None = None
    reports_queue_len: int | None = None

@router.get("", response_model=dict)
def health_simple():
    # Í∏∞Ï°¥ settings.ENV ‚Üí settings.APP_ENV Î°ú ÏàòÏ†ï
    return {"status": "ok", "env": getattr(settings, "APP_ENV", "local")}

@router.get("/extended", response_model=HealthOut)
def health_extended():
    try:
        r = redis.from_url(settings.REDIS_URL)
        ping = r.ping()
        q = Queue("reports", connection=r)
        # rq Î≤ÑÏ†ÑÎ≥Ñ Ìò∏Ìôò
        try:
            qlen = q.count  # RQ>=1.10ÏùÄ property
            if callable(qlen):  # ÌòπÏãú Ìï®ÏàòÎ©¥ Ìò∏Ï∂ú
                qlen = q.count()
        except Exception:
            try:
                qlen = q.count()
            except Exception:
                try:
                    qlen = len(q.job_ids)
                except Exception:
                    qlen = None
        return HealthOut(status="ok", env=getattr(settings, "APP_ENV", "local"),
                         redis_ping=ping, reports_queue_len=qlen)
    except Exception:
        return HealthOut(status="degraded", env=getattr(settings, "APP_ENV", "local"),
                         redis_ping=False, reports_queue_len=None)


================================================================================
 FILE: hrro.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\api\v1\hrro.py
 TYPE: Python Code (Internal)
================================================================================

# app/api/v1/HRRO.py
from __future__ import annotations

from typing import Optional, Union
from dataclasses import asdict

from fastapi import APIRouter
from pydantic import BaseModel, Field

# [Ï£ºÏùò] app.services.simulation Í≤ΩÎ°úÍ∞Ä Ïã§Ï†ú ÌîÑÎ°úÏ†ùÌä∏ÏôÄ ÏùºÏπòÌï¥Ïïº Ìï©ÎãàÎã§.
from app.services.simulation import (
    simulate_HRRO_cycle,
    HRRO_find_pressure_for_flux,
)

# ÎùºÏö∞ÌÑ∞ Í∞ùÏ≤¥ ÏÉùÏÑ± (TagsÏôÄ PrefixÎäî api.pyÏóêÏÑú ÌÜµÌï© Í¥ÄÎ¶¨)
router = APIRouter()


# ---------- Pydantic Schemas ----------

class HRROOptions(BaseModel):
    """HRRO Í≥ÑÏÇ∞ ÏòµÏÖò (Îßâ Ïπ¥ÌÉàÎ°úÍ∑∏/ÏàòÎèô ÌååÎùºÎØ∏ÌÑ∞ Îëò Îã§ ÏàòÏö©)."""
    pump_eff: Optional[float] = None
    erd_eff: Optional[float] = None
    segments: Optional[int] = None
    channel_length_m: Optional[float] = None
    spacer_height_mm: Optional[float] = None
    hydraulic_d_mm: Optional[float] = None

    # Îßâ Ïπ¥ÌÉàÎ°úÍ∑∏ / ÏàòÎèô Ï†ïÏùò
    membrane: Optional[str] = None
    A: Optional[float] = None
    B: Optional[float] = None
    area: Optional[float] = None
    max_flux: Optional[float] = None

    # ÌéåÌîÑ Ìö®Ïú® Ïª§Î∏å & Í∏∞ÌÉÄ Î™®Îìú
    pump_eff_curve: Optional[list[list[float]]] = None
    HRRO_recovery_mode: Optional[str] = None


# [Legacy] Í∏∞Ï°¥ HRROForm Ìò∏ÌôòÏö© flat ÏûÖÎ†•
class HRROSolveIn(BaseModel):
    C0_mgL: float
    V0_m3: float
    T_C: float
    elements: int
    p_set_bar: float
    recirc_flow_m3h: float
    bleed_m3h: float = 0.0
    makeup_tds_mgL: Optional[float] = None
    timestep_s: int = 5
    max_minutes: float = 60.0
    stop_permeate_tds_mgL: Optional[float] = None
    stop_recovery_pct: Optional[float] = None
    options: HRROOptions = Field(default_factory=HRROOptions)


# [New] FlowBuilder Ìò∏ÌôòÏö© feed + stage ÏûÖÎ†•
class HRRORunFeed(BaseModel):
    flow_m3h: float
    tds_mgL: float
    temperature_C: float
    ph: float

class HRRORunStage(BaseModel):
    elements: int
    p_set_bar: float
    recirc_flow_m3h: float
    bleed_m3h: float = 0.0
    loop_volume_m3: float
    makeup_tds_mgL: Optional[float] = None
    timestep_s: int = 5
    max_minutes: float = 60.0
    stop_permeate_tds_mgL: Optional[float] = None
    stop_recovery_pct: Optional[float] = None
    membrane: Optional[str] = None 


class HRRORunIn(BaseModel):
    """FlowBuilder.tsx ÏóêÏÑú ÏÇ¨Ïö©ÌïòÎäî ÏûÖÎ†• ÌòïÌÉú (feed + stage + options)."""
    feed: HRRORunFeed
    stage: HRRORunStage
    options: HRROOptions = Field(default_factory=HRROOptions)


class HRROCycleOut(BaseModel):
    minutes: float
    V_loop_final_m3: float
    C_loop_final_mgL: float
    Qp_total_m3: float
    Cp_mix_mgL: float
    bleed_total_m3: float
    recovery_pct: float
    avg_Jw_lmh: float
    avg_ndp_bar: float
    avg_sec_kwhm3: float
    p_set_bar: float
    avg_delta_pi_bar: float


class PressureForFluxIn(BaseModel):
    C0_mgL: float
    V0_m3: float
    T_C: float
    elements: int
    recirc_flow_m3h: float
    bleed_m3h: float = 0.0
    makeup_tds_mgL: float
    timestep_s: int = 5
    max_minutes: float = 60.0
    target_flux_lmh: float
    options: HRROOptions = Field(default_factory=HRROOptions)
    p_lo: float = 8.0
    p_hi: float = 50.0
    iters: int = 16


class PressureForFluxOut(BaseModel):
    best_pressure_bar: float
    p_set_bar: float
    cycle: HRROCycleOut


# ---------- Helper: Normalize Input ----------

def _normalize_to_flat(payload: Union[HRROSolveIn, HRRORunIn]) -> HRROSolveIn:
    """HRRORunIn(Feed+Stage) ÏûÖÎ†•ÏùÑ Î∞õÏúºÎ©¥ HRROSolveIn(Flat)ÏúºÎ°ú Î≥ÄÌôò"""
    if isinstance(payload, HRROSolveIn):
        return payload

    # HRRORunIn Ï≤òÎ¶¨
    feed = payload.feed
    stage = payload.stage
    opts_dict = payload.options.model_dump(exclude_none=True)

    if stage.membrane is not None:
        opts_dict.setdefault("membrane", stage.membrane)

    return HRROSolveIn(
        C0_mgL=feed.tds_mgL,
        V0_m3=stage.loop_volume_m3,
        T_C=feed.temperature_C,
        elements=stage.elements,
        p_set_bar=stage.p_set_bar,
        recirc_flow_m3h=stage.recirc_flow_m3h,
        bleed_m3h=stage.bleed_m3h,
        makeup_tds_mgL=stage.makeup_tds_mgL,
        timestep_s=stage.timestep_s,
        max_minutes=stage.max_minutes,
        stop_permeate_tds_mgL=stage.stop_permeate_tds_mgL,
        stop_recovery_pct=stage.stop_recovery_pct,
        options=HRROOptions(**opts_dict),
    )


# ---------- Endpoints ----------

@router.post(
    "/solve",
    response_model=HRROCycleOut,
    response_model_exclude_none=True,
    summary="Run Single HRRO Node Simulation"
)
def HRRO_solve(payload: Union[HRROSolveIn, HRRORunIn]) -> HRROCycleOut:
    """
    Îã®Ïùº HRRO ÎÖ∏Îìú Í≥ÑÏÇ∞ (FlowBuilder Í∞úÎ≥Ñ ÎÖ∏Îìú Ïã§ÌñâÏö©)
    """
    p = _normalize_to_flat(payload)

    cc = simulate_HRRO_cycle(
        C0_mgL=p.C0_mgL,
        V0_m3=p.V0_m3,
        T_C=p.T_C,
        elements=p.elements,
        p_set_bar=p.p_set_bar,
        recirc_flow_m3h=p.recirc_flow_m3h,
        bleed_m3h=p.bleed_m3h,
        makeup_tds_mgL=p.makeup_tds_mgL,
        timestep_s=p.timestep_s,
        max_minutes=p.max_minutes,
        stop_permeate_tds_mgL=p.stop_permeate_tds_mgL,
        stop_recovery_pct=p.stop_recovery_pct,
        options=p.options.model_dump(exclude_none=True),
    )
    return HRROCycleOut(**asdict(cc))


@router.post(
    "/pressure-for-flux",
    response_model=PressureForFluxOut,
    response_model_exclude_none=True,
)
def HRRO_pressure_for_flux(payload: PressureForFluxIn) -> PressureForFluxOut:
    """
    Î™©Ìëú FluxÎ•º ÏúÑÌïú ÏïïÎ†• Ï∞æÍ∏∞
    """
    best_p, cc = HRRO_find_pressure_for_flux(
        C0_mgL=payload.C0_mgL,
        V0_m3=payload.V0_m3,
        T_C=payload.T_C,
        elements=payload.elements,
        recirc_flow_m3h=payload.recirc_flow_m3h,
        bleed_m3h=payload.bleed_m3h,
        makeup_tds_mgL=payload.makeup_tds_mgL,
        timestep_s=payload.timestep_s,
        max_minutes=payload.max_minutes,
        target_flux_lmh=payload.target_flux_lmh,
        options=payload.options.model_dump(exclude_none=True),
        p_lo=payload.p_lo,
        p_hi=payload.p_hi,
        iters=payload.iters,
    )
    best_p = round(best_p, 3)
    return PressureForFluxOut(
        best_pressure_bar=best_p,
        p_set_bar=best_p,
        cycle=HRROCycleOut(**asdict(cc)),
    )

================================================================================
 FILE: reports.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\api\v1\reports.py
 TYPE: Python Code (Internal)
================================================================================

from __future__ import annotations

from uuid import UUID
from pathlib import Path
import json

from fastapi import APIRouter, Depends, HTTPException, Query
from fastapi.responses import FileResponse
from sqlalchemy.orm import Session

from app.db.session import get_db
from app.db.models import Scenario, ReportJob, ReportStatus
from .schemas import EnqueueReportIn, EnqueueReportOut, ReportStatusOut, ScenarioInput

import redis
from rq import Queue, Retry, job
from app.core.config import settings
from app.services.tasks import task_generate_report
from app.core.fs import find_report_pdf

# üîß Ïó¨Í∏∞! v1ÏùÑ ÎπºÍ≥† /reports Î°úÎßå Îë°ÎãàÎã§. (main.pyÏóêÏÑú /api/v1 ÏùÑ Î∂ôÏùº Í±∞ÎùºÏÑú)
router = APIRouter(
    prefix="/reports",
    tags=["reports"],
)

def _json_maybe(v):
    if v is None:
        return None
    if isinstance(v, (dict, list)):
        return v
    if isinstance(v, str):
        try:
            return json.loads(v)
        except Exception:
            return None
    return v

@router.post(":enqueue", response_model=EnqueueReportOut)
def enqueue_report(
    payload: EnqueueReportIn,
    out_units: str | None = Query(default=None, description="Set 'display' to render PDF in display units"),
    project_id: str | None = Query(default=None),
    user_id: str | None = Query(default=None),
    db: Session = Depends(get_db)
):
    # üî¥ PK Î¨∏ÏûêÏó¥Î°ú Ï°∞Ìöå (SQLite TEXT PK ÎåÄÎπÑ)
    scn = db.get(Scenario, str(payload.scenario_id))
    if not scn:
        raise HTTPException(404, "scenario not found")

    in_dict = None
    raw = getattr(scn, "input_json", None)
    if raw is not None:
        parsed = _json_maybe(raw)
        if isinstance(parsed, dict):
            in_dict = dict(parsed)

    if in_dict is None:
        in_dict = {
            "project_id": getattr(scn, "project_id", None),
            "scenario_name": getattr(scn, "name", None) or getattr(scn, "scenario_name", None),
            "feed": _json_maybe(getattr(scn, "feed", None) or getattr(scn, "feed_json", None)),
            "stages": _json_maybe(getattr(scn, "stages", None) or getattr(scn, "stages_json", None)),
            "options": _json_maybe(getattr(scn, "options", None)) or {},
        }

    try:
        sim_in = ScenarioInput(**in_dict)
    except Exception as e:
        raise HTTPException(409, f"scenario input invalid: {e}")

    task_payload = sim_in.model_dump()

    job_row = ReportJob(
        scenario_id=scn.id,
        status=ReportStatus.queued,
        queue="reports",
    )
    db.add(job_row); db.commit(); db.refresh(job_row)

    # RQ enqueue (+ ÌëúÏãúÎã®ÏúÑ/Ïä§ÏΩîÌîÑ Ïù∏Ïûê Ï†ÑÎã¨)
    r = redis.from_url(settings.REDIS_URL)
    q = Queue("reports", connection=r)
    q.enqueue(
        task_generate_report,
        task_payload,
        str(job_row.id),
        out_units,
        project_id,
        user_id,
        job_id=str(job_row.id),
        retry=Retry(max=3),
        ttl=600,
        result_ttl=86400,
    )

    return EnqueueReportOut(job_id=job_row.id)

# Ïä¨ÎûòÏãú Î≤ÑÏ†ÑÎèÑ Ìï®Íªò ÏßÄÏõê: /api/v1/reports/enqueue
@router.post("/enqueue", response_model=EnqueueReportOut)
def enqueue_report_alias(
    payload: EnqueueReportIn,
    out_units: str | None = Query(default=None),
    project_id: str | None = Query(default=None),
    user_id: str | None = Query(default=None),
    db: Session = Depends(get_db)
):
    return enqueue_report(payload, out_units, project_id, user_id, db)

@router.get("/{job_id}", response_model=ReportStatusOut)
def get_report_status(job_id: UUID, db: Session = Depends(get_db)):
    job_row = db.get(ReportJob, job_id)
    if not job_row:
        raise HTTPException(404, "job not found")

    artifact_path = getattr(job_row, "artifact_path", None)
    error_message = getattr(job_row, "error_message", None)

    try:
        r = redis.from_url(settings.REDIS_URL)
        rq_job = job.Job.fetch(str(job_id), connection=r)
        if rq_job and not error_message:
            meta_msg = (rq_job.meta or {}).get("error_message")
            if meta_msg:
                error_message = meta_msg
            elif rq_job.exc_info:
                error_message = rq_job.exc_info.splitlines()[-1][:500]
    except Exception:
        pass

    return ReportStatusOut(
        job_id=job_row.id,
        status=job_row.status.value,
        artifact_path=artifact_path,
        error_message=error_message,
        enqueued_at=getattr(job_row, "enqueued_at", None),
        started_at=getattr(job_row, "started_at", None),
        finished_at=getattr(job_row, "finished_at", None)
    )

@router.get("/{job_id}/download")
def download_report(job_id: UUID, db: Session = Depends(get_db)):
    job_row = db.get(ReportJob, job_id)
    if not job_row:
        raise HTTPException(404, "job not found")
    if job_row.status != ReportStatus.succeeded:
        raise HTTPException(409, f"job not ready: {job_row.status.value}")

    artifact_path = getattr(job_row, "artifact_path", None)
    candidates = []

    if artifact_path:
        p = Path(artifact_path)
        if not p.is_absolute():
            p = Path.cwd() / p
        candidates.append(p)

    # ÌååÏùº Í∑úÏπô Í∏∞Î∞ò ÌÉêÏÉâ(Ïù¥Î¶Ñ Î≥ÄÌòï/ÎåÄÏÜåÎ¨∏Ïûê Îì±)
    alt = find_report_pdf(str(job_id))
    if alt:
        candidates.append(alt)

    for p in candidates:
        if p.exists():
            return FileResponse(p, media_type="application/pdf", filename=p.name)

    raise HTTPException(404, "artifact file missing on disk")


================================================================================
 FILE: __init__.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\api\v1\routers\__init__.py
 TYPE: Python Code (Internal)
================================================================================



================================================================================
 FILE: schemas.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\api\v1\schemas.py
 TYPE: Python Code (Internal)
================================================================================

# app/api/v1/schemas.py
from __future__ import annotations

from enum import Enum
from typing import List, Dict, Any, Optional, Literal
from uuid import UUID
from datetime import datetime

from pydantic import BaseModel, Field, field_validator, ConfigDict


# ============================================================
# Per-Stage Metrics (WAVE Style UF/MF Results + Chemistry)
# ============================================================

class StageMetric(BaseModel):
    """
    Í∞Å Ïä§ÌÖåÏù¥ÏßÄ(Stage)Î≥Ñ ÏãúÎÆ¨Î†àÏù¥ÏÖò Í≤∞Í≥º ÏßÄÌëú.
    ÏóîÏßÑÏóêÏÑú Í≥ÑÏÇ∞Îêú Îã§ÏñëÌïú Ï∂îÍ∞Ä Ï†ïÎ≥¥(UF Net Flow Îì±)Î•º Ïú†Ïó∞ÌïòÍ≤å Îã¥Í∏∞ ÏúÑÌï¥ extra="allow" ÏÇ¨Ïö©.
    """
    model_config = ConfigDict(extra="allow") 
    
    stage: int
    pin_bar: Optional[float] = None
    pout_bar: Optional[float] = None
    
    # [RO/NF/HRRO] Standard Metrics
    jw_avg_lmh: Optional[float] = None
    sec_kwh_m3: Optional[float] = None
    delta_pi_bar: Optional[float] = None       # ÏÇºÌà¨Ïïï Ï∞®Ïù¥
    ndp_bar: Optional[float] = None            # Ïú†Ìö® Íµ¨Îèô ÏïïÎ†• (UFÏóêÏÑúÎäî TMP)
    
    # [UF/MF] WAVE-style Operational Metrics
    gross_flow_m3h: Optional[float] = None     # Ïó≠ÏÑ∏Ï≤ô Ï†Ñ ÏàúÏàò ÏÉùÏÇ∞Îüâ (Gross)
    net_flow_m3h: Optional[float] = None       # Ïó≠ÏÑ∏Ï≤ô ÏÜêÏã§ Î∫Ä Ïã§Ï†ú ÏÉùÏÇ∞Îüâ (Net)
    backwash_loss_m3h: Optional[float] = None  # Î≤ÑÎ†§ÏßÄÎäî Î¨º (Waste)
    net_recovery_pct: Optional[float] = None   # Ïú†Ìö® ÌöåÏàòÏú®
    filtration_cycle_min: Optional[float] = None
    
    # Ïä§ÏºÄÏùºÎßÅ ÏßÄÏàò Îì± ÌôîÌïô Ï†ïÎ≥¥
    chemistry: Dict[str, Any] | None = None


# ============================================================
# Inputs ‚Äî Feed / Chemistry / Stages
# ============================================================

class FeedWaterType(str, Enum):
    """WAVE Ïä§ÌÉÄÏùº Water Type Î∂ÑÎ•ò"""
    SEAWATER = "Seawater"
    BRACKISH = "Brackish"
    SURFACE = "Surface"
    GROUNDWATER = "Groundwater"
    WASTEWATER = "Wastewater"
    OTHER = "Other"


class Feed(BaseModel):
    """
    ÏõêÏàò(Feed Water) Ï°∞Í±¥.
    Í∏∞Ï°¥Ïùò ÌïµÏã¨ 4Í∞ú ÌïÑÎìú Ïô∏Ïóê WAVEÏôÄ Ìò∏ÌôòÎêòÎäî ÌôïÏû• ÌïÑÎìúÎì§ÏùÑ Ìè¨Ìï®Ìï©ÎãàÎã§.
    """
    model_config = ConfigDict(extra="ignore")

    # [ÌïµÏã¨ ÌïÑÏàò ÌïÑÎìú]
    flow_m3h: float = Field(gt=0, le=100000)
    tds_mgL: float = Field(ge=0, le=350000)
    temperature_C: float = Field(ge=0, le=90)
    ph: float = Field(ge=0, le=14)

    # [WAVE ÌôïÏû• ÌïÑÎìú - ÏÑ†ÌÉù]
    water_type: FeedWaterType | None = None
    water_subtype: str | None = Field(default=None, max_length=120)
    temperature_min_C: float | None = Field(default=None, ge=0, le=90)
    temperature_max_C: float | None = Field(default=None, ge=0, le=90)
    
    # pH ÏÉÅÏÑ∏
    ph_25C: float | None = Field(default=None, ge=0, le=14)
    ph_note: str | None = Field(default=None, max_length=200)
    
    # Ïò§ÏóºÎ¨ºÏßà ÏßÄÌëú (UF/MF ÏÑ§Í≥ÑÏö©)
    turbidity_ntu: float | None = Field(default=None, ge=0)
    tss_mgL: float | None = Field(default=None, ge=0)
    sdi15: float | None = Field(default=None, ge=0, le=20)
    toc_mgL: float | None = Field(default=None, ge=0)


class WaterChemistryIn(BaseModel):
    """
    Ïä§ÏºÄÏùºÎßÅ Í≥ÑÏÇ∞ÏùÑ ÏúÑÌïú ÏÉÅÏÑ∏ Ïù¥Ïò® Ï°∞ÏÑ±.
    """
    model_config = ConfigDict(extra="ignore")
    
    alkalinity_mgL_as_CaCO3: Optional[float] = Field(default=None, ge=0)
    calcium_hardness_mgL_as_CaCO3: Optional[float] = Field(default=None, ge=0)
    sulfate_mgL: Optional[float] = Field(default=None, ge=0)
    barium_mgL: Optional[float] = Field(default=None, ge=0)
    strontium_mgL: Optional[float] = Field(default=None, ge=0)
    silica_mgL_SiO2: Optional[float] = Field(default=None, ge=0)


# -------- Stage (Updated for Membrane Selection & UF Ops) --------

class Stage(BaseModel):
    """
    Í∞Å Í≥µÏ†ï Îã®Í≥Ñ(Stage)Ïùò ÏÑ§Ï†ïÍ∞í.
    RO/NF/UF/MF/HRRO Îì± Î™®Îì† ÌÉÄÏûÖÏùò ÏÑ§Ï†ïÏùÑ ÌÜµÌï©ÌïòÏó¨ Î∞õÏäµÎãàÎã§.
    """
    model_config = ConfigDict(extra="forbid")

    # Í≥µÌÜµ ÏÑ§Ï†ï
    type: Literal["RO", "UF", "NF", "MF", "MBR", "PUMP", "HRRO"]
    elements: int = Field(ge=1, le=2000)
    
    # ÏïïÎ†• Î∞è ÌöåÏàòÏú® (UF/MFÎäî ÏïïÎ†•Ïù¥ 0Ïùº ÏàòÎèÑ ÏûàÏúºÎØÄÎ°ú Optional + Router Î≥¥Ï†ï)
    pressure_bar: Optional[float] = Field(default=None, ge=0, le=100)
    recovery_target_pct: Optional[float] = Field(default=None, ge=1, le=99)

    # [UF/MF Ï†ÑÏö©] WAVE Ïä§ÌÉÄÏùº Ïó≠ÏÑ∏Ï≤ô(Backwash) ÏÑ§Ï†ï
    filtration_cycle_min: Optional[float] = Field(default=30.0, ge=1.0, description="Ïó¨Í≥º ÏßÄÏÜç ÏãúÍ∞Ñ(Î∂Ñ)")
    backwash_duration_sec: Optional[float] = Field(default=60.0, ge=0.0, description="Ïó≠ÏÑ∏Ï≤ô ÏãúÍ∞Ñ(Ï¥à)")
    backwash_flux_multiplier: Optional[float] = Field(default=1.5, ge=0.5, le=5.0, description="ÏÉùÏÇ∞Ïú†ÏÜç ÎåÄÎπÑ Ïó≠ÏÑ∏Ï≤ôÏú†ÏÜç Î∞∞Ïàò")

    # [HRRO Ï†ÑÏö©] Closed Circuit ÏÑ§Ï†ï
    loop_volume_m3: Optional[float] = Field(default=2.0, ge=0.1)
    recirc_flow_m3h: Optional[float] = Field(default=12.0, ge=0.1)
    bleed_m3h: Optional[float] = Field(default=0.0, ge=0.0)
    makeup_tds_mgL: Optional[float] = None
    timestep_s: Optional[int] = Field(default=5, ge=1)
    max_minutes: Optional[float] = Field(default=60.0, ge=0.1)
    stop_permeate_tds_mgL: Optional[float] = None
    stop_recovery_pct: Optional[float] = None

    # [NEW] Membrane Selection Params (Îßâ ÏÑ†ÌÉù Í∏∞Îä• ÏßÄÏõê)
    # ÌîÑÎ°†Ìä∏ÏóîÎìúÏóêÏÑú Catalog IDÎ•º Î≥¥ÎÇ¥Í±∞ÎÇò, Custom ÏàòÏπòÎ•º Î≥¥ÎÇº Îïå ÏÇ¨Ïö©
    membrane_model: Optional[str] = None  # Ïòà: "BW30-400"
    membrane_area_m2: Optional[float] = None
    membrane_A_lmh_bar: Optional[float] = None
    membrane_B_lmh: Optional[float] = None
    membrane_salt_rejection_pct: Optional[float] = None


# -------- Scenario Input --------

class ScenarioInput(BaseModel):
    """
    ÏãúÎÆ¨Î†àÏù¥ÏÖò Ïã§ÌñâÏùÑ ÏúÑÌïú Ï†ÑÏ≤¥ ÏûÖÎ†• Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞.
    """
    model_config = ConfigDict(extra="forbid")

    project_id: UUID
    scenario_name: str = Field(min_length=1, max_length=120)
    feed: Feed
    stages: List[Stage] = Field(min_length=1, max_length=10)
    options: Dict[str, Any] = Field(default_factory=dict)
    chemistry: Optional[WaterChemistryIn] = None

    @field_validator("stages")
    @classmethod
    def validate_stages(cls, v: List[Stage]):
        allowed = {"RO", "UF", "NF", "MF", "HRRO", "MBR", "PUMP"}
        for s in v:
            if s.type not in allowed:
                raise ValueError(f"Invalid stage type: {s.type}")
        return v


# ============================================================
# Outputs ‚Äî Streams / KPI / Chemistry / Report Job
# ============================================================

class StreamOut(BaseModel):
    label: str
    flow_m3h: float
    tds_mgL: float
    ph: float
    pressure_bar: float


class KPIOut(BaseModel):
    recovery_pct: float
    flux_lmh: float
    ndp_bar: float
    sec_kwhm3: float


class ScalingIndexOut(BaseModel):
    """Ïä§ÏºÄÏùºÎßÅ ÏßÄÏàò (LSI, SDI Îì±)"""
    lsi: Optional[float] = None
    rsi: Optional[float] = None
    s_dsi: Optional[float] = None
    caco3_si: Optional[float] = None
    caso4_si: Optional[float] = None
    baso4_si: Optional[float] = None
    srso4_si: Optional[float] = None
    sio2_si: Optional[float] = None


class WaterChemistryOut(BaseModel):
    """ÏõêÏàò Î∞è ÏµúÏ¢Ö ÎÜçÏ∂ïÏàòÏùò ÌôîÌïôÏ†Å ÏÉÅÌÉú ÏöîÏïΩ"""
    model_config = ConfigDict(extra="allow")
    feed: Optional[ScalingIndexOut] = None
    final_brine: Optional[ScalingIndexOut] = None


class ScenarioOutput(BaseModel):
    """ÏµúÏ¢Ö ÏãúÎÆ¨Î†àÏù¥ÏÖò Í≤∞Í≥º"""
    scenario_id: UUID
    streams: List[StreamOut]
    kpi: KPIOut
    stage_metrics: Optional[List[StageMetric]] = None
    unit_labels: Optional[Dict[str, str]] = None
    chemistry: Optional[WaterChemistryOut] = None


# ============================================================
# Report & Job Queue Models
# ============================================================

class EnqueueReportIn(BaseModel):
    scenario_id: UUID


class EnqueueReportOut(BaseModel):
    job_id: UUID


class ReportStatusOut(BaseModel):
    job_id: UUID
    status: str
    artifact_path: Optional[str] = None
    error_message: Optional[str] = None
    enqueued_at: Optional[datetime] = None
    started_at: Optional[datetime] = None
    finished_at: Optional[datetime] = None


# ============================================================
# Units Configuration
# ============================================================

FlowUnit = Literal["m3/h", "gpm"]
PressureUnit = Literal["bar", "psi"]
TemperatureUnit = Literal["C", "F"]
FluxUnit = Literal["LMH", "gfd"]


class UnitsSettingsIn(BaseModel):
    flow: FlowUnit = Field(default="m3/h")
    pressure: PressureUnit = Field(default="bar")
    temperature: TemperatureUnit = Field(default="C")
    flux: FluxUnit = Field(default="LMH")


class UnitsSettingsOut(UnitsSettingsIn):
    id: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None
    conversions: dict = Field(default_factory=dict)


# ============================================================
# Membranes Catalog Models
# ============================================================

class MembraneSpec(BaseModel):
    """Îßâ Ïπ¥ÌÉàÎ°úÍ∑∏ Ï†ïÎ≥¥"""
    id: str
    name: str | None = None
    vendor: str | None = None
    series: str | None = None
    family: str | None = None  # BWRO, SWRO, NF, UF, MF ...
    size: str | None = None    # 8040, 4040 ...

    # ÌïµÏã¨ ÌååÎùºÎØ∏ÌÑ∞ (ÏóîÏßÑÏóêÏÑú ÏÇ¨Ïö©)
    area_m2: float | None = None
    A_lmh_bar: float | None = None       # Î¨º Ìà¨Í≥ºÎèÑ
    B_mps: float | None = None           # Ïóº Ìà¨Í≥ºÎèÑ
    salt_rejection_pct: float | None = None

    notes: str | None = None


class MembraneOut(MembraneSpec):
    """Î™©Î°ù/Îã®Í±¥ Ï°∞Ìöå ÏùëÎãµ"""
    pass

================================================================================
 FILE: simulation.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\api\v1\simulation.py
 TYPE: Python Code (Internal)
================================================================================

# app/api/v1/simulation.py
from __future__ import annotations

import sys
import traceback
from typing import Dict, Optional, Any

from fastapi import APIRouter, Depends, Query, Body, HTTPException
from sqlalchemy.orm import Session

from app.db.session import get_db
from app.db.models.user_settings import UserSettings
from app.api.v1.schemas import (
    ScenarioInput, ScenarioOutput, StreamOut, KPIOut, StageMetric,
)
from app.services.units import Units, compute_conversions
from app.services.units_apply_out import (
    to_display_streams, to_display_kpi, to_display_stage_metrics, unit_labels,
)

# Membrane DB Load
try:
    from app.data.membranes import MEMBRANES
except Exception:
    MEMBRANES = {}

router = APIRouter(tags=["simulations"])
router_alias = APIRouter(tags=["simulations"])

# --- Utils ---
def _lin_apply(v: Optional[float], scale: float, offset: float) -> Optional[float]:
    if v is None: return None
    try: return float(v) * float(scale) + float(offset)
    except: return v

def _get_scoped_units(db: Session, project_id: str | None, user_id: str | None) -> Units:
    try:
        UserSettings.__table__.create(bind=db.bind, checkfirst=True)
        row = db.query(UserSettings).filter(
            (UserSettings.project_id == project_id) if project_id else (UserSettings.project_id.is_(None)),
            (UserSettings.user_id == user_id) if user_id else (UserSettings.user_id.is_(None)),
        ).first()
        if not row:
            row = UserSettings(project_id=project_id, user_id=user_id)
            db.add(row); db.commit(); db.refresh(row)
        return Units(row.units_flow, row.units_pressure, row.units_temperature, row.units_flux)
    except:
        return Units()

def _convert_input_from_display(si: ScenarioInput, conv: Dict[str, Dict[str, float]]) -> ScenarioInput:
    data = si.model_dump()
    f = data.get("feed") or {}
    if "flow_m3h" in f:
        s = conv["flow"]["from_display"]
        f["flow_m3h"] = _lin_apply(f["flow_m3h"], s["scale"], s["offset"])
    if "temperature_C" in f:
        s = conv["temperature"]["from_display"]
        f["temperature_C"] = _lin_apply(f["temperature_C"], s["scale"], s["offset"])
    data["feed"] = f
    stages = data.get("stages") or []
    if isinstance(stages, list):
        s = conv["pressure"]["from_display"]
        for st in stages:
            if "pressure_bar" in st and st["pressure_bar"] is not None:
                st["pressure_bar"] = _lin_apply(st["pressure_bar"], s["scale"], s["offset"])
    data["stages"] = stages
    return ScenarioInput(**data)

# --- Endpoint ---
@router.post("/run", response_model=ScenarioOutput)
@router_alias.post("/simulations:run", response_model=ScenarioOutput, include_in_schema=False)
@router_alias.post("/simulation:run",  response_model=ScenarioOutput, include_in_schema=False)
@router_alias.post("/simulation/run",  response_model=ScenarioOutput, include_in_schema=False)
def run_simulation(
    payload_data: Dict[str, Any] = Body(...),
    units: str | None = Query(default=None),
    out_units: str | None = Query(default=None),
    project_id: str | None = Query(default=None),
    user_id: str | None = Query(default=None),
    db: Session = Depends(get_db),
):
    print("\n[DEBUG] API '/run' endpoint hit")
    sys.stdout.flush()

    try:
        # [FIX] Circular Import Î∞©ÏßÄÎ•º ÏúÑÌï¥ Ìï®Ïàò ÎÇ¥Î∂ÄÏóêÏÑú import
        from app.services.simulation.engine import run_l1_simulation
        
        # 1. Data Patching
        if "stages" in payload_data and isinstance(payload_data["stages"], list):
            for st in payload_data["stages"]:
                if "pressure_bar" not in st or not st["pressure_bar"]:
                    st["pressure_bar"] = 0.1
        
        # 2. Validation
        try:
            payload = ScenarioInput(**payload_data)
        except Exception as e:
            print(f"[VALIDATION ERROR] {e}")
            raise HTTPException(status_code=422, detail=str(e))

        # 3. Unit Conversion
        u = _get_scoped_units(db, project_id, user_id)
        conv = compute_conversions(u)
        sim_in = payload
        if (units or "").lower() == "display":
            sim_in = _convert_input_from_display(payload, conv)

        # 4. Run Simulation
        sim_out = run_l1_simulation(sim_in)
        print("[DEBUG] run_l1_simulation completed")

        # 5. Result Dump
        streams_data = [s.model_dump() for s in sim_out.streams]
        kpi_data = sim_out.kpi.model_dump()
        
        stage_metrics_data = []
        if sim_out.stage_metrics:
            stage_metrics_data = [m.model_dump(exclude_none=False) for m in sim_out.stage_metrics]
            
        chemistry_data = getattr(sim_out, "chemistry", None)

        # Output Unit Conversion
        unit_lbls = None
        if (out_units or "").lower() == "display":
            streams_data = to_display_streams(streams_data, conv)
            kpi_data = to_display_kpi(kpi_data, conv)
            stage_metrics_data = to_display_stage_metrics(stage_metrics_data, conv)
            unit_lbls = unit_labels(conv)

        return ScenarioOutput(
            scenario_id=sim_out.scenario_id,
            streams=[StreamOut(**s) for s in streams_data],
            kpi=KPIOut(**kpi_data),
            stage_metrics=[StageMetric(**m) for m in stage_metrics_data] if stage_metrics_data else None,
            unit_labels=unit_lbls,
            chemistry=chemistry_data,
        )

    except HTTPException as he:
        raise he
    except Exception as e:
        print(f"\n[CRITICAL ERROR] {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=str(e))

================================================================================
 FILE: user_settings.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\api\v1\user_settings.py
 TYPE: Python Code (Internal)
================================================================================

# ./app/api/v1/user_settings.py

from __future__ import annotations
from datetime import datetime
from typing import Optional, Tuple
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy import inspect  # [ADDED]
from app.db.session import get_db, engine
from app.db.models.user_settings import UserSettings
from .schemas import UnitsSettingsIn, UnitsSettingsOut
from app.services.units import Units, compute_conversions

router = APIRouter(prefix="/user-settings", tags=["user-settings"])

# [ADDED] ÏïàÏ†Ñ Í∏∞Î≥∏ Îã®ÏúÑ(ÎàÑÎùΩ Ïãú ÏûêÎèô Î≥¥Ï†ï)
DEFAULT_UNITS = {
    "flow": "m3/h",
    "pressure": "bar",
    "temperature": "C",
    "flux": "LMH",
}

def _ensure_table():
    # ÌÖåÏù¥Î∏î ÏóÜÏúºÎ©¥ ÏÉùÏÑ±
    try:
        UserSettings.__table__.create(bind=engine, checkfirst=True)
    except Exception:
        pass

def _migrate_columns():
    """
    [CHANGED]
    - Ïö∞ÏÑ† SQLAlchemy InspectorÎ°ú Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏(ÎπÑ SQLite Ìò∏Ìôò).
    - SQLiteÎ©¥ Í∏∞Ï°¥ PRAGMA Í≤ΩÎ°úÎ°ú Ìè¥Î∞±.
    """
    try:
        if engine.dialect.name != "sqlite":  # [ADDED]
            insp = inspect(engine)
            cols = {c["name"] for c in insp.get_columns("user_settings")}
        else:
            with engine.connect() as conn:
                cols = {row[1] for row in conn.exec_driver_sql("PRAGMA table_info(user_settings)").fetchall()}

        with engine.begin() as conn:
            if "project_id" not in cols:
                conn.exec_driver_sql("ALTER TABLE user_settings ADD COLUMN project_id VARCHAR(36)")
            if "user_id" not in cols:
                conn.exec_driver_sql("ALTER TABLE user_settings ADD COLUMN user_id VARCHAR(64)")
            # Ïú†ÎãàÌÅ¨ Ïù∏Îç±Ïä§(ÏûàÏúºÎ©¥ Î¨¥Ïãú)
            conn.exec_driver_sql(
                "CREATE UNIQUE INDEX IF NOT EXISTS uq_user_settings_scope ON user_settings(project_id, user_id)"
            )
    except Exception:
        # Ïä§ÌÇ§Îßà Î≥ÄÍ≤Ω Ïã§Ìå®Ìï¥ÎèÑ Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò ÎèôÏûëÏùÄ ÏßÄÏÜç
        pass

def _get_scoped(db: Session, project_id: Optional[str], user_id: Optional[str]) -> UserSettings:
    _ensure_table()
    _migrate_columns()
    q = db.query(UserSettings).filter(
        (UserSettings.project_id == project_id) if project_id else (UserSettings.project_id.is_(None)),
        (UserSettings.user_id == user_id) if user_id else (UserSettings.user_id.is_(None)),
    )
    row = q.first()
    if not row:
        row = UserSettings(project_id=project_id, user_id=user_id)
        db.add(row); db.commit(); db.refresh(row)
    return row

def _iso(v):
    return v.isoformat() if isinstance(v, datetime) else None

# [ADDED] ÌòÑÏû¨ row + Í∏∞Î≥∏Í∞íÏúºÎ°ú ÏïàÏ†ÑÌïú Îã®ÏúÑ ÌäúÌîå Î∞òÌôò
def _units_with_defaults(row: UserSettings) -> Tuple[str, str, str, str]:
    flow = row.units_flow or DEFAULT_UNITS["flow"]
    pressure = row.units_pressure or DEFAULT_UNITS["pressure"]
    temperature = row.units_temperature or DEFAULT_UNITS["temperature"]
    flux = row.units_flux or DEFAULT_UNITS["flux"]
    return flow, pressure, temperature, flux

# [ADDED] ÌéòÏù¥Î°úÎìú Î≥ëÌï©(Î∂ÄÎ∂Ñ ÏóÖÎç∞Ïù¥Ìä∏)
def _merge_payload(row: UserSettings, payload: UnitsSettingsIn) -> Tuple[str, str, str, str]:
    cur_flow, cur_pressure, cur_temp, cur_flux = _units_with_defaults(row)
    new_flow = payload.flow if payload.flow is not None else cur_flow
    new_pressure = payload.pressure if payload.pressure is not None else cur_pressure
    new_temp = payload.temperature if payload.temperature is not None else cur_temp
    new_flux = payload.flux if payload.flux is not None else cur_flux
    return new_flow, new_pressure, new_temp, new_flux

@router.get("/units", response_model=UnitsSettingsOut)
def get_units(
    project_id: str | None = Query(default=None),
    user_id: str | None = Query(default=None),
    db: Session = Depends(get_db),
):
    try:
        row = _get_scoped(db, project_id, user_id)
        flow, pressure, temperature, flux = _units_with_defaults(row)  # [CHANGED]
        try:
            u = Units(flow, pressure, temperature, flux)  # Ïú†Ìö®ÏÑ± Í≤ÄÏ¶ù
        except Exception as e:
            # Ï†ÄÏû•Í∞íÏù¥ Ïù¥ÏÉÅÌïòÎ©¥ Í∏∞Î≥∏Í∞íÏúºÎ°ú Î≥µÍµ¨Îêú Î≥¥Í∏∞(conversions Í≥ÑÏÇ∞Ïö©)Îßå Ï†úÍ≥µ
            u = Units(**DEFAULT_UNITS)
        return UnitsSettingsOut(
            id=row.id,
            flow=flow, pressure=pressure, temperature=temperature, flux=flux,
            created_at=_iso(getattr(row, "created_at", None)), updated_at=_iso(getattr(row, "updated_at", None)),
            conversions=compute_conversions(u),
        )
    except SQLAlchemyError as e:
        raise HTTPException(500, f"db_error: {type(e).__name__}: {e}")

@router.put("/units", response_model=UnitsSettingsOut)
def put_units(
    payload: UnitsSettingsIn,
    project_id: str | None = Query(default=None),
    user_id: str | None = Query(default=None),
    db: Session = Depends(get_db),
):
    try:
        row = _get_scoped(db, project_id, user_id)
        # [CHANGED] Î∂ÄÎ∂Ñ ÏóÖÎç∞Ïù¥Ìä∏: None ÌïÑÎìúÎäî Ïú†ÏßÄ
        flow, pressure, temperature, flux = _merge_payload(row, payload)

        # [ADDED] ÏÇ¨Ï†Ñ Í≤ÄÏ¶ù(ÏûòÎ™ªÎêú Îã®ÏúÑÎ©¥ 422)
        try:
            u = Units(flow, pressure, temperature, flux)
        except Exception as e:
            raise HTTPException(status_code=422, detail=f"invalid units: {e}")

        # Ï†ÄÏû•
        row.units_flow = flow
        row.units_pressure = pressure
        row.units_temperature = temperature
        row.units_flux = flux
        db.add(row); db.commit(); db.refresh(row)

        return UnitsSettingsOut(
            id=row.id,
            flow=flow, pressure=pressure, temperature=temperature, flux=flux,
            created_at=_iso(getattr(row, "created_at", None)), updated_at=_iso(getattr(row, "updated_at", None)),
            conversions=compute_conversions(u),
        )
    except HTTPException:
        raise
    except SQLAlchemyError as e:
        raise HTTPException(500, f"db_error: {type(e).__name__}: {e}")


================================================================================
 FILE: config.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\core\config.py
 TYPE: Python Code (Internal)
================================================================================

# app/core/config.py
from __future__ import annotations  # [UNCHANGED]

from functools import lru_cache  # [ADDED]
from pathlib import Path  # [UNCHANGED]
from typing import Literal  # [ADDED]

from pydantic import Field  # [UNCHANGED]
from pydantic_settings import BaseSettings, SettingsConfigDict  # [UNCHANGED]


class Settings(BaseSettings):
    """Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò ÌôòÍ≤Ω ÏÑ§Ï†ï."""  # [ADDED]

    model_config = SettingsConfigDict(  # [CHANGED]
        env_file=".env",
        env_file_encoding="utf-8",
        extra="ignore",
        case_sensitive=False,  # ÌôòÍ≤Ω Î≥ÄÏàò ÎåÄÏÜåÎ¨∏Ïûê Î¨¥Ïãú (Í∏∞Î≥∏Í∞íÍ≥º ÎèôÏùºÌïòÏßÄÎßå Î™ÖÏãú)  # [ADDED]
    )

    # ---------- Í∏∞Î≥∏ ÌôòÍ≤Ω ÏÑ§Ï†ï ----------

    APP_ENV: Literal["local", "dev", "test", "prod"] = Field(  # [CHANGED]
        default="local",
        description="Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Ïã§Ìñâ ÌôòÍ≤Ω (local/dev/test/prod)",
    )

    DB_URL: str = Field(  # [UNCHANGED]
        default="sqlite:///./.data/aquanova.db",
        description="SQLAlchemy DB URL",
    )

    REDIS_URL: str = Field(  # [UNCHANGED]
        default="redis://localhost:6379/0",
        description="Redis / RQ Ïó∞Í≤∞ URL",
    )

    REPORT_DIR: str = Field(  # [UNCHANGED]
        default="reports/outputs",
        description="PDF Îì± Î¶¨Ìè¨Ìä∏ Ï∂úÎ†• ÎîîÎ†âÌÑ∞Î¶¨ (ÏÉÅÎåÄ/Ï†àÎåÄ Í≤ΩÎ°ú Î™®Îëê ÌóàÏö©)",
    )

    BRAND_PRIMARY: str = Field(  # [UNCHANGED]
        default="#0a7cff",
        description="UI Î∞è Î¶¨Ìè¨Ìä∏ Í∏∞Î≥∏ Ìè¨Ïù∏Ìä∏ Ïª¨Îü¨ (hex)",
    )

    FONT_PATH: str = Field(  # [UNCHANGED]
        default="./assets/fonts/NotoSans-Regular.ttf",
        description="Î¶¨Ìè¨Ìä∏ Î†åÎçîÎßÅÏóê ÏÇ¨Ïö©Ìï† TTF Ìè∞Ìä∏ Í≤ΩÎ°ú",
    )

    # ---------- Path Ìé∏Ïùò ÌîÑÎ°úÌçºÌã∞ ----------

    @property
    def REPORT_DIR_ABS(self) -> str:  # [UNCHANGED]
        """Î¶¨Ìè¨Ìä∏ Ï∂úÎ†• ÎîîÎ†âÌÑ∞Î¶¨ Ï†àÎåÄ Í≤ΩÎ°ú (str)."""
        return str(Path(self.REPORT_DIR).resolve())

    @property  # [ADDED]
    def report_dir_path(self) -> Path:
        """Î¶¨Ìè¨Ìä∏ Ï∂úÎ†• ÎîîÎ†âÌÑ∞Î¶¨ Ï†àÎåÄ Í≤ΩÎ°ú (Path Í∞ùÏ≤¥)."""
        return Path(self.REPORT_DIR).resolve()

    @property  # [ADDED]
    def FONT_PATH_ABS(self) -> str:
        """Ìè∞Ìä∏ ÌååÏùº Ï†àÎåÄ Í≤ΩÎ°ú (str)."""
        return str(Path(self.FONT_PATH).resolve())

    @property  # [ADDED]
    def font_path(self) -> Path:
        """Ìè∞Ìä∏ ÌååÏùº Ï†àÎåÄ Í≤ΩÎ°ú (Path Í∞ùÏ≤¥)."""
        return Path(self.FONT_PATH).resolve()


@lru_cache  # [ADDED]
def get_settings() -> Settings:
    """FastAPI DependsÏö© Ïã±Í∏ÄÌÜ§ Settings Ïù∏Ïä§ÌÑ¥Ïä§."""  # [ADDED]
    return Settings()  # [CHANGED]


# Í∏∞Ï°¥ `from app.core.config import settings` Ìå®ÌÑ¥ Ìò∏ÌôòÏö©  # [ADDED]
settings = get_settings()  # [CHANGED]


================================================================================
 FILE: fs.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\core\fs.py
 TYPE: Python Code (Internal)
================================================================================

# ./app/core/fs.py

from pathlib import Path
from app.core.config import settings

def ensure_dirs() -> None:
    Path(".data").mkdir(parents=True, exist_ok=True)
    Path(settings.REPORT_DIR_ABS).mkdir(parents=True, exist_ok=True)

def report_output_path(job_id: str) -> Path:
    return Path(settings.REPORT_DIR_ABS) / f"report_{job_id}.pdf"

def find_report_pdf(job_id: str) -> Path | None:
    candidates = [
        report_output_path(job_id),
        Path(settings.REPORT_DIR_ABS) / f"{job_id}.pdf",
        Path(settings.REPORT_DIR_ABS) / f"{job_id}.PDF",
        Path(settings.REPORT_DIR_ABS) / f"report_{job_id}.PDF"
    ]
    for c in candidates:
        if c.exists():
            return c
    return None

================================================================================
 FILE: membranes.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\data\membranes.py
 TYPE: Python Code (Internal)
================================================================================

# app/data/membranes.py
# Îã®ÏúÑ Î©îÎ™®:
# - A_ref_LMH_per_bar: LMH/bar (25¬∞C Í∏∞Ï§Ä)
# - B_ref_LMH: LMH (25¬∞C Í∏∞Ï§Ä)
# - max_flux_lmh: Í∂åÏû• ÏÉÅÌïú ÌîåÎü≠Ïä§(Í≤ΩÌóòÍ∞í; BW‚âà40, SW‚âà30)
# - feed_spacer_mil ‚Üí h_mm=mil*0.0254 (mm), ÏùºÎ∞òÏ†ÅÏúºÎ°ú 28 mil‚âà0.711 mm, 34 mil‚âà0.864 mm
# - q10_B: B(T) Ïò®ÎèÑÎ≥¥Ï†ï Í≥ÑÏàò (BW‚âà1.035, SW‚âà1.04)

MEMBRANES = [
    # -------------------------
    # Generic templates
    # -------------------------
    {
        "id": "BWRO-8040-generic",  # [UNCHANGED]
        "name": "BWRO 8040 (Generic)",
        "brand": "Generic",
        "model": "BWRO-8040",
        "family": "BWRO",
        "subfamily": "BWRO",
        "size": "8040",
        "area_m2": 37.0,
        "A_ref_LMH_per_bar": 2.00,
        "B_ref_LMH": 0.40,
        "max_flux_lmh": 40.0,
        "feed_spacer_mil": 28,
        "h_mm": 0.711,
        "q10_B": 1.035,
        "notes": "Generic 8-inch brackish RO element",
    },
    {
        "id": "SWRO-8040-generic",  # [UNCHANGED]
        "name": "SWRO 8040 (Generic)",
        "brand": "Generic",
        "model": "SWRO-8040",
        "family": "SWRO",
        "subfamily": "SWRO",
        "size": "8040",
        "area_m2": 40.0,
        "A_ref_LMH_per_bar": 1.20,
        "B_ref_LMH": 0.25,
        "max_flux_lmh": 30.0,
        "feed_spacer_mil": 28,
        "h_mm": 0.711,
        "q10_B": 1.04,
        "notes": "Generic 8-inch seawater RO element",
    },
    {
        "id": "NF-8040-generic",  # [UNCHANGED]
        "name": "NF 8040 (Generic)",
        "brand": "Generic",
        "model": "NF-8040",
        "family": "NF",
        "subfamily": "NF",
        "size": "8040",
        "area_m2": 37.0,
        "notes": "Generic 8-inch nanofiltration element",
    },

    # -------------------------
    # Real 8040 models (Î∏åÎûúÎìúÎ≥Ñ)
    # -------------------------
    {
        "id": "dupont-bw30-pro-400",
        "name": "DuPont BW30 PRO-400",
        "brand": "DuPont",
        "model": "BW30 PRO-400",
        "family": "BWRO",
        "subfamily": "BWRO",
        "size": "8040",
        "area_m2": 37.0,
        "A_ref_LMH_per_bar": 3.395,
        "B_ref_LMH": 0.188,
        "max_flux_lmh": 40.0,
        "feed_spacer_mil": 28,
        "h_mm": 0.711,
        "q10_B": 1.035,
        "stc": {
            "permeate_flow_gpd": 11000, "rejection_pct": 99.6,
            "pressure_bar": 15.5, "tds_mgL": 2000, "temp_C": 25, "recovery_pct": 15, "ph": 8
        },
        "notes": "400 ft¬≤ class BWRO; STC 2000 ppm, 225 psi, 25¬∞C, 15% rec.",
    },
    {
        "id": "toray-tm720-400",
        "name": "Toray TM720-400",
        "brand": "Toray",
        "model": "TM720-400",
        "family": "BWRO",
        "subfamily": "BWRO",
        "size": "8040",
        "area_m2": 37.0,
        "A_ref_LMH_per_bar": 3.149,
        "B_ref_LMH": 0.131,
        "max_flux_lmh": 40.0,
        "feed_spacer_mil": 31,
        "h_mm": 0.787,
        "q10_B": 1.035,
        "stc": {
            "permeate_flow_gpd": 10200, "rejection_pct": 99.7,
            "pressure_bar": 15.5, "tds_mgL": 2000, "temp_C": 25, "recovery_pct": 15
        },
        "notes": "Toray 400 ft¬≤ BWRO; 31 mil spacer.",
    },
    {
        "id": "hydranautics-espa2-ld-8040",
        "name": "Hydranautics ESPA2-LD-8040",
        "brand": "Hydranautics (Nitto)",
        "model": "ESPA2-LD-8040",
        "family": "BWRO",
        "subfamily": "LE",  # Low Energy
        "size": "8040",
        "area_m2": 37.2,
        "A_ref_LMH_per_bar": 4.673,
        "B_ref_LMH": 0.170,
        "max_flux_lmh": 45.0,
        "feed_spacer_mil": 34,
        "h_mm": 0.864,
        "q10_B": 1.035,
        "stc": {
            "permeate_flow_gpd": 10000, "rejection_pct": 99.6,
            "pressure_bar": 10.34, "tds_mgL": 1500, "temp_C": 25, "recovery_pct": 15
        },
        "notes": "LE grade; LD spacer.",
    },
    {
        "id": "lg-bw-400-r",
        "name": "LG BW 400 R",
        "brand": "LG Water Solutions",
        "model": "BW 400 R",
        "family": "BWRO",
        "subfamily": "BWRO",
        "size": "8040",
        "area_m2": 37.0,
        "A_ref_LMH_per_bar": 3.241,
        "B_ref_LMH": 0.180,
        "max_flux_lmh": 40.0,
        "feed_spacer_mil": 34,
        "h_mm": 0.864,
        "q10_B": 1.035,
        "stc": {
            "permeate_flow_gpd": 10500, "rejection_pct": 99.6,
            "pressure_bar": 15.5, "tds_mgL": 2000, "temp_C": 25, "recovery_pct": 15
        },
        "notes": "LG Chem BW series; 34 mil spacer.",
    },
    {
        "id": "lanxess-lewabrane-ro-b400-fr",
        "name": "Lanxess Lewabrane RO B400 FR",
        "brand": "Lanxess",
        "model": "Lewabrane RO B400 FR",
        "family": "BWRO",
        "subfamily": "FR",  # Fouling Resistant
        "size": "8040",
        "area_m2": 37.2,
        "A_ref_LMH_per_bar": 3.223,
        "B_ref_LMH": 0.224,
        "max_flux_lmh": 40.0,
        "feed_spacer_mil": 34,
        "h_mm": 0.864,
        "q10_B": 1.035,
        "stc": {
            "permeate_flow_gpd": 10500, "rejection_pct": 99.5,
            "pressure_bar": 15.5, "tds_mgL": 2000, "temp_C": 25, "recovery_pct": 15
        },
        "notes": "FR variant; 400 ft¬≤ class.",
    },
    {
        "id": "koch-tfc-hr-8040-hr-400-34",
        "name": "Koch TFC HR 8040-HR-400-34",
        "brand": "Koch (Kovalus)",
        "model": "TFC HR 8040-HR-400-34",
        "family": "BWRO",
        "subfamily": "HR",
        "size": "8040",
        "area_m2": 37.2,
        "A_ref_LMH_per_bar": 3.377,
        "B_ref_LMH": 0.234,
        "max_flux_lmh": 40.0,
        "feed_spacer_mil": 34,
        "h_mm": 0.864,
        "q10_B": 1.035,
        "stc": {
            "permeate_flow_gpd": 11000, "rejection_pct": 99.5,
            "pressure_bar": 15.5, "tds_mgL": 2000, "temp_C": 25, "recovery_pct": 15
        },
        "notes": "High rejection HR variant.",
    },
    {
        "id": "hydranautics-swc5-8040",
        "name": "Hydranautics SWC5-8040",
        "brand": "Hydranautics (Nitto)",
        "model": "SWC5-8040",
        "family": "SWRO",
        "subfamily": "SWRO",
        "size": "8040",
        "area_m2": 37.1,
        "A_ref_LMH_per_bar": 1.363,
        "B_ref_LMH": 0.077,
        "max_flux_lmh": 30.0,
        "feed_spacer_mil": 28,
        "h_mm": 0.711,
        "q10_B": 1.04,
        "stc": {
            "permeate_flow_gpd": 9000, "rejection_pct": 99.8,
            "pressure_bar": 55.16, "tds_mgL": 32000, "temp_C": 25, "recovery_pct": 10
        },
        "notes": "Seawater RO; SWC5 series.",
    },
    {
        "id": "dupont-sw30hrle-400",
        "name": "DuPont SW30HRLE-400",
        "brand": "DuPont",
        "model": "SW30HRLE-400",
        "family": "SWRO",
        "subfamily": "HRLE",
        "size": "8040",
        "area_m2": 37.0,
        "A_ref_LMH_per_bar": 1.146,
        "B_ref_LMH": 0.064,
        "max_flux_lmh": 30.0,
        "feed_spacer_mil": 28,
        "h_mm": 0.711,
        "q10_B": 1.04,
        "stc": {
            "permeate_flow_gpd": 7500, "rejection_pct": 99.8,
            "pressure_bar": 55.0, "tds_mgL": 32000, "temp_C": 25, "recovery_pct": 8
        },
        "notes": "High rejection, low energy SWRO.",
    },
    {
        "id": "toray-tm820m-400",
        "name": "Toray TM820M-400",
        "brand": "Toray",
        "model": "TM820M-400",
        "family": "SWRO",
        "subfamily": "SWRO",
        "size": "8040",
        "area_m2": 37.0,
        "A_ref_LMH_per_bar": 1.062,
        "B_ref_LMH": 0.060,
        "max_flux_lmh": 30.0,
        "feed_spacer_mil": 34,
        "h_mm": 0.864,
        "q10_B": 1.04,
        "stc": {
            "permeate_flow_gpd": 7000, "rejection_pct": 99.8,
            "pressure_bar": 55.2, "tds_mgL": 32000, "temp_C": 25, "recovery_pct": 8
        },
        "notes": "Toray 400 ft¬≤ SWRO module.",
    },
    {
        "id": "lg-sw-400-gr",
        "name": "LG SW 400 GR",
        "brand": "LG Water Solutions",
        "model": "SW 400 GR",
        "family": "SWRO",
        "subfamily": "GR",
        "size": "8040",
        "area_m2": 37.0,
        "A_ref_LMH_per_bar": 1.142,
        "B_ref_LMH": 0.048,
        "max_flux_lmh": 30.0,
        "feed_spacer_mil": 34,
        "h_mm": 0.864,
        "q10_B": 1.04,
        "stc": {
            "permeate_flow_gpd": 7500, "rejection_pct": 99.85,
            "pressure_bar": 55.1, "tds_mgL": 32000, "temp_C": 25, "recovery_pct": 8
        },
        "notes": "LG seawater high rejection GR.",
    },
    {
        "id": "vontron-ulp32-8040",
        "name": "Vontron ULP32-8040",
        "brand": "Vontron",
        "model": "ULP32-8040",
        "family": "BWRO",
        "subfamily": "ULP",  # Ultra Low Pressure
        "size": "8040",
        "area_m2": 37.0,
        "A_ref_LMH_per_bar": 3.241,
        "B_ref_LMH": 0.225,
        "max_flux_lmh": 40.0,
        "feed_spacer_mil": 28,
        "h_mm": 0.711,
        "q10_B": 1.035,
        "stc": {
            "permeate_flow_gpd": 10500, "rejection_pct": 99.5,
            "pressure_bar": 15.5, "tds_mgL": 2000, "temp_C": 25, "recovery_pct": 15
        },
        "notes": "ULP series for low-pressure BW applications.",
    },
    {
        "id": "csm-re8040-blr",
        "name": "CSM RE8040-BLR",
        "brand": "CSM (Toray Advanced Materials)",
        "model": "RE8040-BLR",
        "family": "BWRO",
        "subfamily": "LP",
        "size": "8040",
        "area_m2": 37.2,
        "A_ref_LMH_per_bar": 2.765,
        "B_ref_LMH": 0.153,
        "max_flux_lmh": 40.0,
        "feed_spacer_mil": 28,
        "h_mm": 0.711,
        "q10_B": 1.035,
        "stc": {
            "permeate_flow_gpd": 9000, "rejection_pct": 99.6,
            "pressure_bar": 15.5, "tds_mgL": 2000, "temp_C": 25, "recovery_pct": 15
        },
        "notes": "Low-pressure BWRO series.",
    },

    {
        "id": "UF-8040-generic",
        "name": "Generic UF 8040",
        "vendor": "Generic",
        "family": "UF",
        "size": "8040",
        "area_m2": 40.0,
        "A_lmh_bar": 60.0,
        "B_mps": 50.0,
        "salt_rejection_pct": 0.0,
    },
    
    {
        "id": "MF-8040-generic",
        "name": "Generic MF 8040",
        "vendor": "Generic",
        "family": "MF",
        "size": "8040",
        "area_m2": 40.0,
        "A_lmh_bar": 120.0,
        "B_mps": 80.0,
        "salt_rejection_pct": 0.0,
    },
]

================================================================================
 FILE: __init__.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\db\models\__init__.py
 TYPE: Python Code (Internal)
================================================================================

# ./app/db/models/__init__.py

from .base import Base, UUIDMixin, TimestampMixin
from .project import Project
from .scenario import Scenario
from .report_job import ReportJob, ReportStatus
from .user_settings import UserSettings

__all__ = [
    "Base", "UUIDMixin", "TimestampMixin",
    "Project", "Scenario", "ReportJob", "ReportStatus",
]

================================================================================
 FILE: base.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\db\models\base.py
 TYPE: Python Code (Internal)
================================================================================

# ./app/db/models/base.py 

from __future__ import annotations
from datetime import datetime
import uuid

from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column
from sqlalchemy import DateTime, func

class Base(DeclarativeBase):
    pass

class UUIDMixin:
    id: Mapped[uuid.UUID] = mapped_column(default=uuid.uuid4, primary_key=True)

class TimestampMixin:
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False
    )

================================================================================
 FILE: report_job.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\db\models\report_job.py
 TYPE: Python Code (Internal)
================================================================================

# ./app/db/models/report_job.py

from __future__ import annotations
from enum import Enum
from typing import Optional
from datetime import datetime
from uuid import UUID

from sqlalchemy import String, Integer, Text, ForeignKey, DateTime, func
from sqlalchemy.orm import Mapped, mapped_column, relationship
from .base import Base, UUIDMixin, TimestampMixin

class ReportStatus(str, Enum):
    queued = "queued"
    running = "running"
    succeeded = "succeeded"
    failed = "failed"

class ReportJob(UUIDMixin, TimestampMixin, Base):
    __tablename__ = "report_job"

    scenario_id: Mapped[UUID] = mapped_column(
        ForeignKey("scenario.id", ondelete="CASCADE"),
        index=True
    )
    status: Mapped[ReportStatus] = mapped_column(
        default=ReportStatus.queued
    )
    queue: Mapped[str] = mapped_column(
        String(40),
        default="reports"
    )
    retry_count: Mapped[int] = mapped_column(
        Integer,
        default=0
    )
    error_message: Mapped[Optional[str]] = mapped_column(
        Text()
    )
    artifact_path: Mapped[Optional[str]] = mapped_column(
        String(500)
    )
    enqueued_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False
    )
    started_at: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True)
    )
    finished_at: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True)
    )
    scenario: Mapped["Scenario"] = relationship(
        back_populates="report_jobs"
    )


================================================================================
 FILE: user_settings.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\db\models\user_settings.py
 TYPE: Python Code (Internal)
================================================================================

from __future__ import annotations
from datetime import datetime
from uuid import uuid4
from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import String, DateTime, UniqueConstraint
from sqlalchemy.sql import func
from .base import Base

class UserSettings(Base):
    __tablename__ = "user_settings"

    id: Mapped[str] = mapped_column(String(36), primary_key=True, default=lambda: str(uuid4()))

    # Ïä§ÏΩîÌîÑ(Îëò Îã§ NoneÏù¥Î©¥ Í∏ÄÎ°úÎ≤å 1Ìñâ)
    project_id: Mapped[str | None] = mapped_column(String(36), nullable=True, index=True)
    user_id: Mapped[str | None] = mapped_column(String(64), nullable=True, index=True)

    units_flow: Mapped[str] = mapped_column(String(16), default="m3/h")
    units_pressure: Mapped[str] = mapped_column(String(16), default="bar")
    units_temperature: Mapped[str] = mapped_column(String(16), default="C")
    units_flux: Mapped[str] = mapped_column(String(16), default="LMH")

    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())

    __table_args__ = (
        UniqueConstraint("project_id", "user_id", name="uq_user_settings_scope"),
    )


================================================================================
 FILE: session.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\db\session.py
 TYPE: Python Code (Internal)
================================================================================

# ./app/db/session.py

from __future__ import annotations
from contextlib import contextmanager
from typing import Generator
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from pathlib import Path

from app.core.config import settings
from app.db.models.base import Base

# Î™®Îç∏ Í∞ïÏ†ú import (ÏÉùÎûµ Í∏àÏßÄ)
from app.db.models import project as _p  # noqa: F401
from app.db.models import scenario as _s  # noqa: F401
from app.db.models import report_job as _r  # noqa: F401

from app.core.fs import ensure_dirs
ensure_dirs()


def _ensure_sqlite_dir(url: str) -> None:
    """sqlite:///path/to/db.sqlite ÌòïÌÉúÏóêÏÑú Ìè¥Îçî ÏûêÎèô ÏÉùÏÑ±"""
    if not url.startswith("sqlite"):
        return
    # sqlite:///./.data/aquanova.db ‚Üí "./.data/aquanova.db"
    path_part = url.split("///", 1)[1] if "///" in url else url.split("//", 1)[1]
    path_part = path_part.split("?", 1)[0]
    try:
        Path(path_part).parent.mkdir(parents=True, exist_ok=True)
    except Exception:
        pass

_ensure_sqlite_dir(settings.DB_URL)

engine = create_engine(
    settings.DB_URL,
    connect_args={"check_same_thread": False} if settings.DB_URL.startswith("sqlite") else {},
    future=True,
)

SessionLocal = sessionmaker(
    bind=engine,
    autoflush=False,
    autocommit=False,
    future=True,
    expire_on_commit=False,
)

def get_db() -> Generator[Session, None, None]:
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


================================================================================
 FILE: main.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\main.py
 TYPE: Python Code (Entry)
================================================================================

# app/main.py
from __future__ import annotations

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import redis
from rq import Queue

from app.core.config import settings

from app.api.v1.api import api_router

app = FastAPI(
    title="AquaNova API",
    version="0.1.0",
)

# CORS (Î°úÏª¨ Í∞úÎ∞ú ÌóàÏö©)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ===== Global Health Check (Root Level) =====
@app.get("/health", tags=["Global Health"])
def health_root():
    """Î°úÎìúÎ∞∏Îü∞ÏÑúÏö© Îã®Ïàú Ìó¨Ïä§ Ï≤¥ÌÅ¨"""
    return {"status": "ok", "env": getattr(settings, "APP_ENV", "local")}

@app.get("/health/extended", tags=["Global Health"])
def health_root_extended():
    """Redis/Queue ÏÉÅÌÉú Ìè¨Ìï® ÏÉÅÏÑ∏ Ìó¨Ïä§ Ï≤¥ÌÅ¨"""
    try:
        r = redis.from_url(settings.REDIS_URL)
        ping = r.ping()
        q = Queue("reports", connection=r)
        
        # Queue count ÏïàÏ†ÑÌïòÍ≤å Í∞ÄÏ†∏Ïò§Í∏∞
        try:
            qlen = q.count if not callable(getattr(q, "count", None)) else q.count()
        except Exception:
            qlen = len(q.job_ids) if hasattr(q, 'job_ids') else None

        return {
            "status": "ok",
            "env": getattr(settings, "APP_ENV", "local"),
            "redis_ping": bool(ping),
            "reports_queue_len": qlen,
        }
    except Exception:
        return {
            "status": "degraded",
            "env": getattr(settings, "APP_ENV", "local"),
            "redis_ping": False,
            "reports_queue_len": None,
        }

# ===== API V1 ÎùºÏö∞ÌÑ∞ Îì±Î°ù =====
# Ïó¨Í∏∞ÏÑú /api/v1 ÌîÑÎ¶¨ÌîΩÏä§Î•º Ìïú Î≤àÏóê Î∂ôÏûÖÎãàÎã§.
# ÏµúÏ¢Ö Í≤ΩÎ°ú ÏòàÏãú: /api/v1/HRRO/solve
app.include_router(api_router, prefix="/api/v1")


@app.get("/", include_in_schema=False)
def index():
    return {"ok": True, "docs": "/docs", "redoc": "/redoc"}

================================================================================
 FILE: cover.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\reports\templates\cover.py
 TYPE: Python Code (Internal)
================================================================================

# app/reports/templates/cover.py

from __future__ import annotations
from datetime import datetime
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import mm

from app.core.config import settings
from .common import ensure_font, hex_color

def draw_cover(c, scenario_name: str, brand_primary: str | None = None):
    W, H = A4
    font = ensure_font()
    brand = hex_color(brand_primary or getattr(settings, "BRAND_PRIMARY", "#0a7cff"))

    # ÌÉÄÏù¥ÌãÄ Î∞¥Îìú
    c.setFillColor(brand)
    c.rect(0, H - 40*mm, W, 40*mm, fill=1, stroke=0)

    # ÌÉÄÏù¥ÌãÄ
    c.setFillColorRGB(1, 1, 1)
    c.setFont(font, 24)
    c.drawString(20*mm, H - 25*mm, "AquaNova RO Simulation Report")

    # ÏÑúÎ∏åÌÉÄÏù¥ÌãÄ
    c.setFont(font, 12)
    c.drawString(20*mm, H - 35*mm, f"Scenario: {scenario_name}")

    # ÎÇ†Ïßú/ENV
    c.setFillColorRGB(0, 0, 0)
    c.setFont(font, 10)
    c.drawString(20*mm, 20*mm, f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M')}")
    c.drawString(20*mm, 15*mm, f"Env: {getattr(settings, 'APP_ENV', 'local')}")

    c.showPage()


================================================================================
 FILE: stage_metrics.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\reports\templates\stage_metrics.py
 TYPE: Python Code (Internal)
================================================================================

# app/reports/templates/stage_metrics.py  (no matplotlib version)
from __future__ import annotations
from typing import List, Dict, Any, Iterable, Tuple

from reportlab.lib.pagesizes import A4
from reportlab.lib.units import mm
from reportlab.lib import colors

from .common import ensure_font, fmt_num, draw_table, draw_hline

def _u(units: Dict[str, str] | None, key: str, default: str) -> str:
    if not isinstance(units, dict):
        return default
    v = units.get(key)
    return v if isinstance(v, str) and v.strip() else default

def _rows_from_stage_metrics(stage_metrics: List[Dict[str, Any]] | None) -> List[List[str]]:
    if not stage_metrics:
        return []
    rows: list[tuple[float | int | None, list[str]]] = []
    for m in stage_metrics:
        stg  = m.get("stage")
        jw   = m.get("jw_avg_lmh")
        pin  = m.get("pin_bar")
        pout = m.get("pout_bar")
        sec  = m.get("sec_kwh_m3")
        stage_lbl = str(int(stg)) if isinstance(stg, (int, float)) else (str(stg) if stg else "‚Äî")
        rows.append((stg, [
            stage_lbl,
            fmt_num(jw, 1),
            fmt_num(pin, 2),
            fmt_num(pout, 2),
            fmt_num(sec, 3),
        ]))
    try:
        rows.sort(key=lambda x: (9999 if x[0] is None else float(x[0])))
    except Exception:
        pass
    return [r for _, r in rows]

def _series_bounds(values: Iterable[float | None]) -> Tuple[float, float]:
    vs = [float(v) for v in values if isinstance(v, (int, float))]
    if not vs:
        return (0.0, 1.0)
    lo, hi = min(vs), max(vs)
    if hi == lo:
        # ÌèâÌèâÌïòÎ©¥ ÏïΩÍ∞ÑÏùò ÎßàÏßÑ
        return (lo - abs(lo)*0.05 - 1e-6, hi + abs(hi)*0.05 + 1e-6)
    # 5% ÎßàÏßÑ
    span = hi - lo
    return (lo - 0.05*span, hi + 0.05*span)

def _plot_lines(
    c,
    x: float, y: float, w: float, h: float,
    xs: List[float],
    series: List[Tuple[List[float | None], str]],  # [(ys, label)]
    y_unit: str,
    title: str,
):
    font = ensure_font()
    c.setLineWidth(0.8)
    c.setStrokeColor(colors.black)
    c.rect(x, y, w, h, stroke=1, fill=0)

    # Ï†úÎ™©/ÎùºÎ≤®
    c.setFont(font, 10); c.drawString(x, y + h + 2*mm, title)
    c.setFont(font, 8);  c.setFillColorRGB(0.3, 0.3, 0.3)
    c.drawRightString(x + w, y - 3, f"[{y_unit}]")
    c.setFillColorRGB(0, 0, 0)

    # Îç∞Ïù¥ÌÑ∞ Ïú†Î¨¥/Í∞úÏàò
    n = len(xs)
    all_vals = []
    for ys, _ in series:
        all_vals.extend([v for v in ys if isinstance(v, (int, float))])
    if not all_vals:
        c.setFont(font, 8); c.drawString(x + 3, y + h/2, "No data")
        return

    # YÎ≤îÏúÑ
    y_min, y_max = _series_bounds(all_vals)
    def y_to_py(v: float) -> float:
        if y_max == y_min: return y + h/2
        return y + ((v - y_min) / (y_max - y_min)) * h

    # Í∑∏Î¶¨Îìú/ÎààÍ∏à
    c.setLineWidth(0.3); c.setStrokeColor(colors.lightgrey)
    for frac in [0.0, 0.25, 0.5, 0.75, 1.0]:
        gy = y + frac*h
        c.line(x, gy, x+w, gy)
        c.setFont(font, 7); c.setFillColorRGB(0.25, 0.25, 0.25)
        c.drawRightString(x - 2, gy - 2, fmt_num(y_min + frac*(y_max - y_min), 2))
    c.setStrokeColor(colors.black); c.setFillColor(colors.black)

    # ÏÉâ/Ïä§ÌÉÄÏùº
    dash_styles = [None, [2, 2], None, [1, 2]]
    colors_list = [colors.black, colors.darkgrey, colors.blue, colors.red]

    if n >= 2:
        # ÏÑ† Í∑∏ÎûòÌîÑ
        x_coords = [x + (i/(n-1))*w for i in range(n)]
        for idx, (ys, label) in enumerate(series):
            pts = []
            for i, v in enumerate(ys):
                pts.append(None if v is None else (x_coords[i], y_to_py(float(v))))
            c.setLineWidth(1.0 if idx == 0 else 0.8)
            col = colors_list[idx % len(colors_list)]; c.setStrokeColor(col)
            dash = dash_styles[idx % len(dash_styles)]; c.setDash(dash or [])
            last = None
            for p in pts:
                if p is None: last = None; continue
                if last is not None: c.line(last[0], last[1], p[0], p[1])
                last = p
            c.setFont(font, 7); c.setFillColor(col)
            c.drawString(x + 4 + idx*(w*0.25), y + h + 1.5*mm, label)
            c.setFillColor(colors.black)
        # XÏ∂ï stage ÎùºÎ≤®
        c.setFont(font, 7)
        for i in range(n):
            c.drawCentredString(x_coords[i], y - 10, str(int(xs[i])) if isinstance(xs[i], (int, float)) else str(xs[i]))
    else:
        # Îã®Ïùº Ïä§ÌÖåÏù¥ÏßÄ: Ï§ëÏïôÏóê Ï†ê(ÎßàÏª§)
        px = x + w/2
        for idx, (ys, label) in enumerate(series):
            v = next((float(v) for v in ys if isinstance(v, (int, float))), None)
            if v is None: continue
            py = y_to_py(v)
            col = colors_list[idx % len(colors_list)]
            c.setFillColor(col); c.setStrokeColor(col)
            r = 2.5  # Ï†ê Î∞òÍ≤Ω
            c.circle(px, py, r, stroke=1, fill=1)
            c.setFont(font, 7); c.setFillColor(col)
            c.drawString(x + 4 + idx*(w*0.25), y + h + 1.5*mm, f"{label} ‚Ä¢ {fmt_num(v, 2)}")
            c.setFillColor(colors.black)
        # XÏ∂ï ÎùºÎ≤®
        c.setFont(font, 7)
        c.drawCentredString(px, y - 10, str(int(xs[0])) if isinstance(xs[0], (int, float)) else str(xs[0]))

def draw_stage_metrics_page(c, stage_metrics: List[Dict[str, Any]] | None, units: Dict[str, str] | None = None) -> None:
    """
    pdfgen.canvas Í∏∞Î∞ò Ï†ÑÏö© ÌéòÏù¥ÏßÄ: Stage Metrics Ìëú + 3 ÎØ∏Îãà Ï∞®Ìä∏(Avg Flux / Pin¬∑Pout / Stage SEC)
    """
    W, H = A4
    x0, x1 = 20*mm, W - 20*mm
    y = H - 25*mm
    font = ensure_font()

    # ÌÉÄÏù¥ÌãÄ
    c.setFont(font, 16)
    c.drawString(x0, y, "Stage Metrics"); y -= 8
    draw_hline(c, x0, x1, y); y -= 14

    if not stage_metrics:
        c.setFont(font, 10)
        c.drawString(x0, y, "No per-stage metrics were available.")
        return

    # Ìëú
    headers = [
        "Stage",
        f"Jw avg ({_u(units,'flux','LMH')})",
        f"Pin ({_u(units,'pressure','bar')})",
        f"Pout ({_u(units,'pressure','bar')})",
        "SEC (kWh/m¬≥)"
    ]
    rows = _rows_from_stage_metrics(stage_metrics)

    total_w = x1 - x0
    col_ws = [total_w*0.14, total_w*0.24, total_w*0.21, total_w*0.21, total_w*0.20]

    approx_h = (1 + len(rows)) * 16 + 20
    chart_h = 58*mm
    gap = 8*mm
    need_h = approx_h + gap + chart_h

    if y - need_h < 15*mm:
        c.showPage()
        y = H - 25*mm
        c.setFont(font, 16)
        c.drawString(x0, y, "Stage Metrics"); y -= 8
        draw_hline(c, x0, x1, y); y -= 14

    y = draw_table(
        c, x0, y,
        col_headers=headers,
        rows=rows,
        col_widths=col_ws,
        row_h=16,
        text_font=font,
        text_size=9,
    ) - 10

    # Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞
    xs   = [m.get("stage") for m in stage_metrics if m.get("stage") is not None]
    flux = [m.get("jw_avg_lmh") for m in stage_metrics if m.get("stage") is not None]
    pin  = [m.get("pin_bar")    for m in stage_metrics if m.get("stage") is not None]
    pout = [m.get("pout_bar")   for m in stage_metrics if m.get("stage") is not None]
    sec  = [m.get("sec_kwh_m3") for m in stage_metrics if m.get("stage") is not None]

    if y - chart_h < 20*mm:
        c.showPage()
        y = H - 30*mm  # ÏúÑ Ïó¨Î∞± ÏÇ¥Ïßù Îçî

    # 3Îì±Î∂Ñ Î∞∞Ïπò
    w_total = (x1 - x0)
    gap_x = 6*mm
    each_w = (w_total - 2*gap_x) / 3.0
    xA = x0
    xB = xA + each_w + gap_x
    xC = xB + each_w + gap_x

    # (1) Avg Flux
    _plot_lines(
        c, xA, y - chart_h, each_w, chart_h,
        xs=xs,
        series=[(flux, "Avg Flux")],
        y_unit=_u(units, "flux", "LMH"),
        title="Avg Flux"
    )

    # (2) Pin/Pout
    _plot_lines(
        c, xB, y - chart_h, each_w, chart_h,
        xs=xs,
        series=[(pin, "Pin"), (pout, "Pout")],
        y_unit=_u(units, "pressure", "bar"),
        title="Pin / Pout"
    )

    # (3) Stage SEC
    _plot_lines(
        c, xC, y - chart_h, each_w, chart_h,
        xs=xs,
        series=[(sec, "SEC")],
        y_unit=_u(units, "sec", "kWh/m¬≥"),
        title="Stage SEC"
    )


================================================================================
 FILE: summary.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\reports\templates\summary.py
 TYPE: Python Code (Internal)
================================================================================

# ./app/reports/templates/summary.py

from __future__ import annotations
from typing import Any, Dict, List, Tuple

from reportlab.lib.pagesizes import A4
from reportlab.lib.units import mm
from reportlab.lib.colors import black
from reportlab.pdfgen import canvas

from .common import ensure_font, fmt_num, draw_table, draw_hline

# streamsÏóêÏÑú ÏñµÏßÄÎ°ú ÎΩëÏïÑÎÇ¥Îäî Í≥ºÍ±∞ Ìò∏Ìôò(ÏóÜÏúºÎ©¥ stage_metrics ÏÇ¨Ïö©)
_STAGE_KEYS = ("stage", "stage_no", "stage_index", "stage_id", "idx")
_PIN_KEYS   = ("Pin_bar", "pin_bar", "inlet_pressure_bar", "P_in_bar", "inlet_bar", "Pin")
_POUT_KEYS  = ("Pout_bar", "pout_bar", "outlet_pressure_bar", "P_out_bar", "outlet_bar", "Pout")
_JW_KEYS    = ("Jw_avg_Lmh", "Jw_avg_LMH", "avg_LMH", "Jw_LMH", "Jw_avg")
_SEC_KEYS   = ("SEC_kWh_m3", "sec_kwh_m3", "SEC_kWh_per_m3", "sec_kwhm3")

def _get_first(d: Dict[str, Any], keys: Tuple[str, ...], default=None):
    for k in keys:
        if k in d and d[k] is not None:
            return d[k]
    return default

def _rows_from_stage_metrics(stage_metrics: List[Dict[str, Any]] | None) -> List[List[str]]:
    """Ïã†Í∑ú: ÏóîÏßÑÏù¥ Ï§Ä stage_metricsÏóêÏÑú Ìëú Ìñâ ÏÉùÏÑ±."""
    if not stage_metrics:
        return []
    rows = []
    for m in stage_metrics:
        stg = m.get("stage")
        pin = m.get("pin_bar")
        pout= m.get("pout_bar")
        jw  = m.get("jw_avg_lmh")
        sec = m.get("sec_kwh_m3")
        stage_lbl = str(int(stg)) if isinstance(stg, (int, float)) else (str(stg) if stg else "‚Äî")
        rows.append((stg, [
            stage_lbl,
            fmt_num(pin, 2),
            fmt_num(pout, 2),
            fmt_num(jw, 1),
            fmt_num(sec, 3),
        ]))
    try:
        rows.sort(key=lambda x: (9999 if x[0] is None else float(x[0])))
    except Exception:
        pass
    return [r for _, r in rows]

def _rows_from_streams(streams: List[Dict[str, Any]] | None) -> List[List[str]]:
    """Î†àÍ±∞Ïãú: streams ÎîïÌä∏ÏóêÏÑú Ïú†ÏÇ¨ ÌÇ§Î•º Ï∞æÏïÑ Ìñâ ÏÉùÏÑ±(Í∞ÄÎä•ÌïòÎ©¥ stage_metricsÎ•º Ïì∞Ïûê)."""
    if not streams:
        return []
    rows = []
    for s in streams:
        stg  = _get_first(s, _STAGE_KEYS, None)
        pin  = _get_first(s, _PIN_KEYS,   None)
        pout = _get_first(s, _POUT_KEYS,  None)
        jw   = _get_first(s, _JW_KEYS,    None)
        sec  = _get_first(s, _SEC_KEYS,   None)

        # ÏµúÏÜåÌïú stageÏôÄ ÌïòÎÇò Ïù¥ÏÉÅÏùò Í∞íÏù¥ ÏûàÏñ¥Ïïº ÏùòÎØ∏ ÏûàÏùå
        if stg is None and all(v is None for v in (pin, pout, jw, sec)):
            continue

        stage_lbl = str(int(stg)) if isinstance(stg, (int, float)) else (str(stg) if stg else "‚Äî")
        rows.append((stg, [
            stage_lbl,
            fmt_num(pin, 2),
            fmt_num(pout, 2),
            fmt_num(jw, 1),
            fmt_num(sec, 3),
        ]))
    try:
        rows.sort(key=lambda x: (9999 if x[0] is None else float(x[0])))
    except Exception:
        pass
    return [r for _, r in rows]

def draw_system_summary(
        c: canvas.Canvas,
        streams: list[dict],
        kpi: dict,
        units: dict | None = None,         # {"flow":"m3/h","pressure":"bar","flux":"LMH"}
        stage_metrics: list[dict] | None = None  # <<== Ïã†Í∑ú: ÌëúÎäî Ïù¥Í±∏ Ïö∞ÏÑ† ÏÇ¨Ïö©
):
    units = units or {"flow":"m3/h","pressure":"bar","flux":"LMH"}
    W, H   = A4
    font   = ensure_font()
    x0, x1 = 20*mm, W - 20*mm
    y      = H - 25*mm

    # Ï†úÎ™©
    c.setFont(font, 16)
    c.setFillColor(black)
    c.drawString(x0, y, "System Summary"); y -= 8
    draw_hline(c, x0, x1, y); y -= 10

    # KPI
    c.setFont(font, 10)
    k_map = [
        ("Total Recovery (%)",                           ("recovery_pct", "total_recovery_pct", "recovery", "RecoveryPct")),
        (f"Permeate Flow ({units.get('flow','m3/h')})",  ("permeate_m3h", "permeate_flow_m3h", "Qp_m3h")),
        (f"Feed Flow ({units.get('flow','m3/h')})",      ("feed_m3h", "feed_flow_m3h", "Qf_m3h")),
        ("SEC Total (kWh/m¬≥)",                           ("sec_kwh_m3", "SEC_kWh_m3", "SEC_total", "sec_total", "sec_kwhm3")),
        (f"NDP ({units.get('pressure','bar')})",         ("ndp_bar", "NDP_bar", "deltaP_bar")),
        (f"Flux ({units.get('flux','LMH')})",            ("flux_lmh", "Flux_LMH", "Jw_LMH_avg")),
    ]
    for label, keys in k_map:
        val = _get_first(kpi or {}, keys, None) if isinstance(kpi, dict) else None
        c.drawString(x0, y, f"- {label}: {fmt_num(val, 3)}"); y -= 14
        if y < 30*mm:
            c.showPage(); y = H - 25*mm; c.setFont(font, 10)

    y -= 6

    # Ïä§ÌÖåÏù¥ÏßÄÎ≥Ñ Ìëú (stage_metrics Ïö∞ÏÑ†)
    c.setFont(font, 12)
    c.drawString(x0, y, "Per-Stage Metrics"); y -= 6
    draw_hline(c, x0, x1, y); y -= 10

    headers = [
        "Stage",
        f"Pin ({units.get('pressure','bar')})",
        f"Pout ({units.get('pressure','bar')})",
        f"Jw avg ({units.get('flux','LMH')})",
        "SEC (kWh/m¬≥)"
    ]

    rows = _rows_from_stage_metrics(stage_metrics) if stage_metrics else _rows_from_streams(streams)

    total_w = x1 - x0
    col_ws = [total_w*0.14, total_w*0.21, total_w*0.21, total_w*0.22, total_w*0.22]

    if rows:
        approx_h = (1 + len(rows)) * 16 + 20
        if y - approx_h < 15*mm:
            c.showPage(); y = H - 25*mm
        y = draw_table(
            c, x0, y,
            col_headers = headers,
            rows = rows,
            col_widths = col_ws,
            row_h = 16,
            text_font = font,
            text_size = 9,
        ) - 10
    else:
        c.setFont(font, 9)
        c.drawString(x0, y, "No per-stage metrics were available."); y -= 10

    if y < 15*mm:
        c.showPage()


================================================================================
 FILE: membranes.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\services\membranes.py
 TYPE: Python Code (Internal)
================================================================================

# app/services/membranes.py
from __future__ import annotations
from typing import Any, Optional, Dict, Tuple
from app.api.v1.schemas import MembraneSpec
from app.api.v1.schemas import MembraneOut
from app.data.membranes import MEMBRANES

def _as_list() -> list[dict[str, Any]]:
    src = MEMBRANES
    if isinstance(src, dict):
        return [dict(id=k, **(v or {})) for k, v in src.items()]
    return list(src or [])

def _normalize(raw: dict[str, Any]) -> MembraneSpec:
    # Îã§ÏñëÌïú ÌÇ§ ÎåÄÏùë
    def pick_num(d: dict, *keys: str) -> Optional[float]:
        for k in keys:
            v = d.get(k)
            if v is None:
                continue
            try:
                vv = float(v)
                if vv == vv:  # not NaN
                    return vv
            except Exception:
                pass
        return None

    return MembraneSpec(
        id=str(raw.get("id") or raw.get("code") or raw.get("name") or "").strip(),
        name=raw.get("name") or raw.get("display_name"),
        vendor=raw.get("vendor") or raw.get("brand") or raw.get("maker"),
        series=raw.get("series") or raw.get("model"),
        family=raw.get("family") or raw.get("type"),
        size=raw.get("size"),
        area_m2=pick_num(raw, "area_m2", "active_area_m2", "area"),
        A_lmh_bar=pick_num(raw, "A_lmh_bar", "A", "water_perm_Lmh_bar", "water_permeability"),
        B_mps=pick_num(raw, "B_mps", "B", "salt_perm_mps", "salt_permeability"),
        salt_rejection_pct=pick_num(raw, "salt_rejection_pct", "rejection_pct", "NaCl_rejection_pct", "rejection"),
        notes=raw.get("notes"),
    )

def load_by_id(code: str) -> Optional[MembraneSpec]:
    if not code:
        return None
    cid = str(code).strip().lower()
    for m in _as_list():
        mid = str(m.get("id") or "").strip().lower()
        if mid == cid:
            spec = _normalize(m)
            # ÏµúÏÜå ÏïàÏ†Ñ Í∏∞Î≥∏Í∞í Î≥¥Ï†ï
            if spec.area_m2 is None:
                spec.area_m2 = 37.0 if (spec.size or "").startswith("8040") else 7.9
            return spec
    return None

def normalize_spec(obj: Any) -> Optional[MembraneSpec]:
    """dict/str/None Î¨¥ÏóáÏù¥ Ïò§Îì† MembraneSpecÏúºÎ°ú Ï†ïÍ∑úÌôî."""
    if obj is None:
        return None
    if isinstance(obj, MembraneSpec):
        return obj
    if isinstance(obj, dict):
        # dictÎ°ú ÏßÅÏ†ë ÎÑòÏñ¥Ïò§Î©¥ ÏµúÎåÄÌïú ÎßûÏ∂∞ÏÑú Î≥¥Ï†ï
        try:
            spec = MembraneSpec(**obj)
        except Exception:
            spec = _normalize(obj)
        if spec.area_m2 is None:
            spec.area_m2 = 37.0
        return spec
    if isinstance(obj, str):
        return load_by_id(obj)
    return None

def resolve_from_options(options: Dict[str, Any] | None) -> MembraneSpec:
    """optionsÏóêÏÑú membrane_spec ÎòêÎäî membrane_code/Î¨∏ÏûêÏó¥ÏùÑ Ï∞æÏïÑ Ï†ïÍ∑úÌôî."""
    opts = options or {}
    # Ïö∞ÏÑ†ÏàúÏúÑ: Î™ÖÏãú Ïä§Ìéô(dict) > ÏΩîÎìú/Î¨∏ÏûêÏó¥
    spec = normalize_spec(opts.get("membrane_spec"))
    if spec:
        return spec
    spec = normalize_spec(opts.get("membrane_code") or opts.get("membrane"))
    if spec:
        return spec
    # ÏµúÏ¢Ö Í∏∞Î≥∏Í∞í (ÏóîÏßÑÏù¥ Î∞òÎìúÏãú ÌïÑÏöîÎ°ú Ìï† Í∞í)
    return MembraneSpec(id="default-8040", name="Default 8040", area_m2=37.0, A_lmh_bar=3.0, B_mps=1.5e-7)

# === Ï∂îÍ∞Ä: ÏãúÎÆ¨Î†àÏù¥ÌÑ∞Í∞Ä Î∞îÎ°ú Ïì∏ Ïàò ÏûàÎäî ÌååÎùºÎØ∏ÌÑ∞ Ï∂îÏ∂úÍ∏∞ ===
def get_params_from_options(
    options: Dict[str, Any] | None,
    stage_type: str | None = "RO",
) -> Dict[str, float]:
    """
    options + Ïπ¥ÌÉàÎ°úÍ∑∏(MEMBRANES + ÏÇ¨Ïö©ÏûêÍ∞Ä ÎÑ£ÏùÄ spec)Î•º Î≥ëÌï©Ìï¥
    ÏãúÎÆ¨ ÏóîÏßÑÏóêÏÑú Î∞îÎ°ú Ïì∞Îäî dictÎ°ú Î≥ÄÌôò.
    Î∞òÌôò ÌÇ§:
      - A (LMH/bar), B_lmh (LMH), area (m2/element), max_flux (LMH), salt_rejection_pct (0~1)
    """  # [ADDED]
    opts = dict(options or {})
    st = (stage_type or "RO").upper()

    # 1) Ïπ¥ÌÉàÎ°úÍ∑∏/Ïä§Ìéô
    spec = resolve_from_options(opts)

    # 2) Î©¥Ï†Å/Ìà¨Í≥ºÎèÑ (ÏòµÏÖòÏù¥ Ïö∞ÏÑ†)
    area = float(opts.get("area_m2") or opts.get("membrane_area_m2") or spec.area_m2 or 37.0)
    A = float(opts.get("A_lmh_bar") or opts.get("A") or spec.A_lmh_bar or 2.0)

    # B: LMH ÎòêÎäî m/s ‚Üí LMH Î≥ÄÌôò(1 m/s = 3,600,000 LMH)
    if "B_lmh" in opts:
        B_lmh = float(opts["B_lmh"])
    elif "B" in opts:
        B_lmh = float(opts["B"])
    else:
        B_lmh = (float(spec.B_mps) * 3_600_000.0) if (spec.B_mps is not None) else 0.40  # Í∏∞Î≥∏Í∞í [ADDED]

    # 3) max_flux Í∏∞Î≥∏Ïπò
    max_flux = float(opts.get("max_flux") or 40.0)

    # 4) Ï†úÍ±∞Ïú® Í∏∞Î≥∏Ïπò (0~1)
    if "salt_rejection_pct" in opts:
        rej = float(opts["salt_rejection_pct"])
        salt_rejection_pct = rej if rej <= 1.0 else rej / 100.0
    elif spec.salt_rejection_pct is not None:
        salt_rejection_pct = float(spec.salt_rejection_pct)
        salt_rejection_pct = salt_rejection_pct if salt_rejection_pct <= 1.0 else salt_rejection_pct / 100.0
    else:
        # ÌÉÄÏûÖÎ≥Ñ Í∏∞Î≥∏
        salt_rejection_pct = {
            "RO": 0.99,
            "SWRO": 0.995,
            "NF": 0.60,
            "UF": 0.0,
            "MF": 0.0,
        }.get(st, 0.99)

    return dict(A=A, B_lmh=B_lmh, area=area, max_flux=max_flux, salt_rejection_pct=salt_rejection_pct)  # [ADDED]


def family_for_stage(stage_type: str | None) -> str | None:  # [ADDED]
    st = (stage_type or "").upper()
    if st in ("RO", "HRRO"):
        return "RO"
    if st in ("NF", "UF", "MF"):
        return st
    return None

# --- NEW: Spec ‚Üí API Out Î≥ÄÌôò Ìó¨Ìçº ---  # [ADDED]
def _to_out(spec: MembraneSpec) -> MembraneOut:  # [ADDED]
    return MembraneOut(**spec.model_dump())

def list_membranes(  # [CHANGED] ÌïÑÌÑ∞ ÌôïÏû•
    family: str | None = None,
    size: str | None = None,
    q: str | None = None,
    limit: int | None = None,
) -> list[MembraneOut]:
    fam = family.upper() if family else None
    ql = (q or "").strip().lower()
    out: list[MembraneOut] = []
    for raw in _as_list():
        spec = _normalize(raw)

        if fam:
            s_fam = (spec.family or "").upper()
            if s_fam != fam:
                continue
        if size and spec.size and str(spec.size).strip().lower() != str(size).strip().lower():
            continue
        if ql:
            hay = " ".join([
                spec.id or "",
                spec.name or "",
                spec.vendor or "",
                spec.series or "",
                spec.family or "",
                spec.size or "",
            ]).lower()
            if ql not in hay:
                continue

        out.append(_to_out(spec))
        if limit and len(out) >= limit:
            break
    return out

# --- NEW: Îã®Í±¥ Ï°∞ÌöåÏö© ---  # [ADDED]
def get_membrane_out_by_id(membrane_id: str) -> Optional[MembraneOut]:  # [ADDED]
    spec = load_by_id(membrane_id)
    return _to_out(spec) if spec else None


================================================================================
 FILE: __init__.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\services\simulation\__init__.py
 TYPE: Python Code (Internal)
================================================================================

# app/services/simulation/__init__.py

# ==============================================================================
# [Î≥µÍµ¨] ÏàúÌôò Ï∞∏Ï°∞ Î∞©ÏßÄÏö© Lazy Import
# ÏÑúÎ≤Ñ ÏãúÏûë Ïãú engine.pyÎ•º ÎØ∏Î¶¨ Î°úÎìúÌïòÏßÄ ÏïäÍ≥†, Ïã§Ï†ú ÏöîÏ≤≠Ïù¥ Îì§Ïñ¥Ïò¨ Îïå Î°úÎìúÌï©ÎãàÎã§.
# ==============================================================================

from app.services.simulation.models import StageResult, HRROCycleResult
from app.services.simulation.utils import temp_correct_A, clamp, mps_to_lmh, lmh_to_mps

# Ìè¥ÎçîÎ™Ö Ìò∏ÌôòÏÑ± (solver vs solvers)
try:
    from app.services.simulation.solvers import solve_stage_given_pin, solve_stage_by_recovery, simulate_HRRO_cycle
except ImportError:
    from app.services.simulation.solver import solve_stage_given_pin, solve_stage_by_recovery, simulate_HRRO_cycle

# Engine Ìï®ÏàòÎì§ÏùÑ Ìò∏Ï∂ú ÏãúÏ†êÏóê import ÌïòÎèÑÎ°ù ÎûòÌïë
def run_l1_simulation(*args, **kwargs):
    from .engine import run_l1_simulation as _run
    return _run(*args, **kwargs)

def simulate_stages(*args, **kwargs):
    from .engine import simulate_stages as _sim
    return _sim(*args, **kwargs)

def HRRO_find_pressure_for_flux(*args, **kwargs):
    from .engine import HRRO_find_pressure_for_flux as _find
    return _find(*args, **kwargs)

__all__ = [
    "run_l1_simulation",
    "simulate_stages",
    "simulate_HRRO_cycle",
    "HRRO_find_pressure_for_flux",
    "StageResult",
    "HRROCycleResult",
    "solve_stage_given_pin",
    "solve_stage_by_recovery",
    "temp_correct_A",
    "clamp",
    "mps_to_lmh",
    "lmh_to_mps"
]

================================================================================
 FILE: engine.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\services\simulation\engine.py
 TYPE: Python Code (Internal)
================================================================================

# app/services/simulation/engine.py
from typing import List, Tuple, Dict, Any, Optional
from uuid import uuid4, UUID
import traceback

from app.api.v1.schemas import (
    ScenarioInput, ScenarioOutput, StreamOut, KPIOut, StageMetric,
    WaterChemistryOut, ScalingIndexOut,
)
from app.services.water_chemistry import (
    ChemistryProfile, scale_profile_for_tds, calc_scaling_indices,
)
from app.services.simulation.models import StageResult, HRROCycleResult

# Import ÏïàÏ†ÑÏû•Ïπò
try:
    try:
        from app.services.simulation.solvers.steady_state import solve_stage_given_pin, solve_stage_by_recovery
    except ImportError:
        from app.services.simulation.solver.steady_state import solve_stage_given_pin, solve_stage_by_recovery

    try:
        from app.services.simulation.solver.hrro import simulate_HRRO_cycle
    except ImportError:
        from app.services.simulation.solvers.hrro import simulate_HRRO_cycle
except ImportError:
    pass

def simulate_stages(payload: ScenarioInput) -> Tuple[List[Any], Dict[str, float], List[Dict[str, Any]]]:
    Q_feed = float(payload.feed.flow_m3h)
    C_feed = float(payload.feed.tds_mgL)
    T = float(payload.feed.temperature_C)
    global_options = payload.options or {}
    stages_out = []
    wave_metrics_list = [] 
    curr_Q = Q_feed
    curr_C = C_feed
    total_net_prod = 0.0
    total_salt_p = 0.0
    weighted_sec = 0.0
    
    for st_input in payload.stages:
        st_type = (st_input.type or "RO").upper()
        stage_options = global_options.copy()
        
        # Îßâ ÏÑ†ÌÉù ÏòµÏÖò Ï†ÅÏö©
        if st_input.membrane_model: stage_options["membrane_id"] = st_input.membrane_model
        if st_input.membrane_area_m2: stage_options["area"] = st_input.membrane_area_m2
        if st_input.membrane_A_lmh_bar: stage_options["A"] = st_input.membrane_A_lmh_bar
        if st_input.membrane_B_lmh: stage_options["B_lmh"] = st_input.membrane_B_lmh
        if st_input.membrane_salt_rejection_pct: stage_options["salt_rejection_pct"] = st_input.membrane_salt_rejection_pct

        # HRRO
        if st_type == "HRRO":
            p_set = float(st_input.pressure_bar or 30.0)
            V0 = float(st_input.loop_volume_m3 or 2.0)
            rec_flow = float(st_input.recirc_flow_m3h or curr_Q)
            res = simulate_HRRO_cycle(C0_mgL=curr_C, V0_m3=V0, T_C=T, elements=st_input.elements, p_set_bar=p_set, recirc_flow_m3h=rec_flow, bleed_m3h=float(st_input.bleed_m3h or 0.0), makeup_tds_mgL=curr_C, timestep_s=int(st_input.timestep_s or 5), max_minutes=float(st_input.max_minutes or 60.0), stop_permeate_tds_mgL=st_input.stop_permeate_tds_mgL, stop_recovery_pct=st_input.recovery_target_pct, options=stage_options)
            stages_out.append(res)
            total_net_prod += res.Qp_total_m3
            total_salt_p += (res.Qp_total_m3 * res.Cp_mix_mgL)
            weighted_sec += (res.avg_sec_kwhm3 * res.Qp_total_m3)
            if res.minutes > 0: curr_Q = res.bleed_total_m3 / (res.minutes / 60.0)
            else: curr_Q = 0.0
            curr_C = res.C_loop_final_mgL
            wave_metrics_list.append({}) 
        
        # Steady State
        else:
            if st_input.recovery_target_pct:
                res = solve_stage_by_recovery(curr_Q, curr_C, T, st_input.elements, st_input.recovery_target_pct/100.0, stage_options, st_type)
            else:
                p_in = float(st_input.pressure_bar) if st_input.pressure_bar is not None else 2.0
                res = solve_stage_given_pin(curr_Q, curr_C, T, st_input.elements, p_in, stage_options, st_type)
            
            wave_meta = {}
            net_Qp = res.Qp
            if st_type in ["UF", "MF", "ULTRAFILTRATION", "MICROFILTRATION"]:
                cycle_min = float(st_input.filtration_cycle_min or 30.0)
                bw_sec = float(st_input.backwash_duration_sec or 60.0)
                bw_mult = float(st_input.backwash_flux_multiplier or 1.5)
                bw_min = bw_sec / 60.0
                total_cycle_min = cycle_min + bw_min
                Q_gross = res.Qp
                if total_cycle_min > 0:
                    Vol_prod = Q_gross * (cycle_min / 60.0)
                    Vol_bw = (Q_gross * bw_mult) * (bw_min / 60.0)
                    Q_net = (Vol_prod - Vol_bw) / (total_cycle_min / 60.0)
                    net_rec = (Q_net / max(res.Qf, 1e-9)) * 100.0
                else: Q_net, net_rec = 0.0, 0.0
                wave_meta = { "gross_flow_m3h": round(Q_gross, 2), "net_flow_m3h": round(Q_net, 2), "backwash_loss_m3h": round((Q_gross - Q_net), 2), "net_recovery_pct": round(net_rec, 2), "filtration_cycle_min": cycle_min }
                net_Qp = Q_net
            stages_out.append(res)
            wave_metrics_list.append(wave_meta)
            total_net_prod += net_Qp
            total_salt_p += (net_Qp * res.Cp)
            weighted_sec += (res.sec_kwhm3 * net_Qp)
            curr_Q = res.Qb; curr_C = res.Cb

    avg_sec = weighted_sec / max(total_net_prod, 1e-9)
    avg_cp = total_salt_p / max(total_net_prod, 1e-9)
    total_rec = (total_net_prod / max(Q_feed, 1e-9)) * 100.0 if Q_feed > 0 else 0.0
    avg_flux, avg_ndp, valid_cnt = 0.0, 0.0, 0
    for s in stages_out:
        jw = getattr(s, 'avg_Jw_lmh', getattr(s, 'avg_Jw', 0))
        ndp = getattr(s, 'avg_ndp_bar', 0)
        if jw > 0: avg_flux += jw; avg_ndp += ndp; valid_cnt += 1
    if valid_cnt > 0: avg_flux /= valid_cnt; avg_ndp /= valid_cnt

    kpis = {"recovery_pct": total_rec, "flux_lmh": avg_flux, "ndp_bar": avg_ndp, "sec_kwhm3": avg_sec, "permeate_tds_mgL": avg_cp}
    return stages_out, kpis, wave_metrics_list

def run_l1_simulation(payload: ScenarioInput) -> ScenarioOutput:
    print(f"\n [NEW ENGINE] Simulation Started!")
    try:
        stages_out, kpis, wave_metrics = simulate_stages(payload)
        streams = [StreamOut(label="Feed", flow_m3h=payload.feed.flow_m3h, tds_mgL=payload.feed.tds_mgL, ph=payload.feed.ph, pressure_bar=0.0)]
        stage_metrics_res = []
        chem_in = getattr(payload, "chemistry", None)
        chem_profile = None
        if chem_in:
            chem_profile = ChemistryProfile(tds_mgL=payload.feed.tds_mgL, temperature_C=payload.feed.temperature_C, ph=payload.feed.ph, alkalinity_mgL_as_CaCO3=chem_in.alkalinity_mgL_as_CaCO3, calcium_hardness_mgL_as_CaCO3=chem_in.calcium_hardness_mgL_as_CaCO3, sulfate_mgL=chem_in.sulfate_mgL, barium_mgL=chem_in.barium_mgL, strontium_mgL=chem_in.strontium_mgL, silica_mgL=chem_in.silica_mgL_SiO2)

        for i, s in enumerate(stages_out):
            idx = i + 1
            w_meta = wave_metrics[i] if i < len(wave_metrics) else {}
            disp_flow = w_meta.get("net_flow_m3h", s.Qp if hasattr(s, 'Qp') else s.Qp_total_m3)
            
            # [ÌïµÏã¨] UI ÌÖåÎßàÏö© Î™®Îìà ÌÉÄÏûÖ Ï£ºÏûÖ
            st_type_str = (payload.stages[i].type or "RO").upper()
            
            try:
                base_data = {
                   "stage": idx, "chemistry": None, 
                   "module_type": st_type_str, # ÌÖåÎßà Í≤∞Ï†ï ÌÇ§
                   "pin_bar": getattr(s, 'p_set_bar', getattr(s, 'p_in_bar', 0)),
                   "pout_bar": getattr(s, 'p_set_bar', getattr(s, 'p_out_bar', 0)),
                   "jw_avg_lmh": getattr(s, 'avg_Jw_lmh', getattr(s, 'avg_Jw', 0)),
                   "sec_kwh_m3": getattr(s, 'avg_sec_kwhm3', getattr(s, 'sec_kwhm3', 0)),
                   "delta_pi_bar": getattr(s, 'avg_delta_pi_bar', 0),
                   "ndp_bar": getattr(s, 'avg_ndp_bar', 0),
                }
                if isinstance(s, HRROCycleResult):
                    avg_flow = s.Qp_total_m3 / max(s.minutes/60.0, 1e-9)
                    streams.append(StreamOut(label=f"Stage{idx}_Permeate", flow_m3h=avg_flow, tds_mgL=s.Cp_mix_mgL, ph=6.5, pressure_bar=0.0))
                    if chem_profile:
                        loop_prof = scale_profile_for_tds(chem_profile, s.C_loop_final_mgL)
                        base_data["chemistry"] = { "feed": calc_scaling_indices(chem_profile), "brine": calc_scaling_indices(loop_prof) }
                        chem_profile = loop_prof
                    base_data["net_recovery_pct"] = s.recovery_pct
                    base_data["filtration_cycle_min"] = s.minutes
                    stage_metrics_res.append(StageMetric(**base_data))
                else:
                    streams.append(StreamOut(label=f"Stage{idx}_Permeate", flow_m3h=disp_flow, tds_mgL=s.Cp, ph=6.5, pressure_bar=0.0))
                    streams.append(StreamOut(label=f"Stage{idx}_Brine", flow_m3h=s.Qb, tds_mgL=s.Cb, ph=7.0, pressure_bar=s.p_out_bar))
                    if chem_profile:
                        brine_prof = scale_profile_for_tds(chem_profile, s.Cb)
                        base_data["chemistry"] = { "feed": calc_scaling_indices(chem_profile), "brine": calc_scaling_indices(brine_prof) }
                        chem_profile = brine_prof
                    if w_meta: base_data.update(w_meta)
                    clean_data = {k: v for k, v in base_data.items() if v is not None}
                    stage_metrics_res.append(StageMetric(**clean_data))
            except Exception as inner_e:
                print(f"[WARNING] Stage {idx} processing error: {inner_e}")
                continue

        chem_out = None
        if chem_profile and chem_in: 
            chem_out = WaterChemistryOut(feed=None, final_brine=calc_scaling_indices(chem_profile) if chem_profile else None)

        return ScenarioOutput(scenario_id=UUID(str(uuid4())), streams=streams, kpi=KPIOut(**kpis), stage_metrics=stage_metrics_res, chemistry=chem_out)
    except Exception as e:
        print("\n[CRITICAL ERROR in Engine]")
        traceback.print_exc()
        raise e

================================================================================
 FILE: models.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\services\simulation\models.py
 TYPE: Python Code (Internal)
================================================================================

# app/services/simulation/models.py
from dataclasses import dataclass

@dataclass
class StageResult:
    Qf: float; Cf: float          # ÏûÖÎ†• Ïú†Îüâ/ÎÜçÎèÑ
    Qp: float; Cp: float          # ÏÉùÏÇ∞Ïàò
    Qb: float; Cb: float          # ÎÜçÏ∂ïÏàò
    avg_Jw: float                 # ÌèâÍ∑† Flux (LMH)
    avg_ndp_bar: float            # ÌèâÍ∑† Ïú†Ìö®Íµ¨ÎèôÏïïÎ†•
    avg_delta_pi_bar: float       # ÌèâÍ∑† ÏÇºÌà¨Ïïï Ï∞®
    p_in_bar: float               # ÏûÖÍµ¨ ÏïïÎ†•
    p_out_bar: float              # Ï∂úÍµ¨ ÏïïÎ†•
    sec_kwhm3: float              # ÎπÑÏóêÎÑàÏßÄÏÜåÎπÑ (SEC)

@dataclass
class HRROCycleResult:
    minutes: float
    V_loop_final_m3: float
    C_loop_final_mgL: float
    Qp_total_m3: float
    Cp_mix_mgL: float
    bleed_total_m3: float
    recovery_pct: float
    avg_Jw_lmh: float
    avg_ndp_bar: float
    avg_delta_pi_bar: float
    avg_sec_kwhm3: float
    p_set_bar: float

================================================================================
 FILE: solvers.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\services\simulation\solvers.py
 TYPE: Python Code (Internal)
================================================================================

# app/services/simulation/solvers.py
import math
from typing import Dict, Any, Tuple

from app.services.transport import (
    osmotic_pressure_bar, density_water_kg_m3, viscosity_water_pa_s,
    mass_transfer_k_m_s, delta_p_darcy_pa, pa_to_bar
)
from app.services.simulation.utils import (
    clamp, temp_correct_A, lmh_to_mps, mps_to_lmh, P_PERM_BAR
)
from app.services.simulation.models import StageResult, HRROCycleResult
from app.services.simulation.specs import resolve_membrane_params

# ============================================================
# Ïä§ÌÖåÏù¥ÏßÄ Ìï¥ÏÑù (Plug Flow)
# ============================================================

def solve_stage_given_pin(
    Qf_m3h: float,
    Cf_mgL: float,
    T_C: float,
    elements: int,
    p_in_bar: float,
    options: Dict[str, Any],
    stage_type: str = "RO",
) -> StageResult:
    st = (stage_type or "RO").upper()

    # ÌååÎùºÎØ∏ÌÑ∞ Î°úÎìú
    mem = resolve_membrane_params(options, stage_type=st)
    
    A_ref = float(mem["A"])
    B_lmh = float(mem["B_lmh"])
    area_per = float(mem["area"])
    max_flux = float(mem.get("max_flux", 100.0))
    
    rej_user = options.get("salt_rejection_pct")
    salt_rejection = float(rej_user) / 100.0 if rej_user is not None else None

    # Ïò®ÎèÑ Î≥¥Ï†ï
    A_eff = temp_correct_A(A_ref, T_C)
    
    # Ï±ÑÎÑê ÏßÄÏò§Î©îÌä∏Î¶¨
    nseg = int(options.get("segments", 20))
    L_total = float(options.get("channel_length_m", 1.0))
    h_mm = float(options.get("spacer_height_mm", 0.7))
    d_h = float(options.get("hydraulic_d_mm", 2.0 * h_mm)) / 1000.0
    h = h_mm / 1000.0

    # Î¨ºÏÑ±Ïπò
    rho = density_water_kg_m3(T_C)
    mu  = viscosity_water_pa_s(T_C)

    stage_area = elements * area_per
    width_total = (stage_area / (2.0 * L_total)) 
    A_cross = h * width_total
    
    L_seg = L_total / nseg
    area_seg = stage_area / nseg

    # Ï¥àÍ∏∞Ìôî
    Qf_curr = max(Qf_m3h, 1e-9)
    Cf_curr = max(Cf_mgL, 0.0)
    p_local = p_in_bar

    total_Qp = 0.0
    total_salt_p = 0.0
    sum_Jw = 0.0
    sum_ndp = 0.0
    sum_dpi = 0.0
    hydraulic_W = 0.0

    # Ï¥àÍ∏∞ Flux Ï∂îÏ†ï
    pi_f = osmotic_pressure_bar(Cf_curr, T_C)
    ndp0 = max(p_in_bar - P_PERM_BAR - (pi_f if st != "UF" else 0), 0.0)
    prev_Jw = clamp(A_eff * ndp0, 0.0, max_flux)

    for _ in range(nseg):
        v = (Qf_curr / 3600.0) / max(A_cross, 1e-9)
        k = mass_transfer_k_m_s(v, d_h, T_C, rho=rho, mu=mu)

        # Iterative Solving for Jw, Cp
        Jw = prev_Jw
        dpi = 0.0
        
        for _iter in range(5): 
            Jw_mps = lmh_to_mps(Jw)
            
            # ÎÜçÎèÑ Î∂ÑÍ∑π
            exp_factor = math.exp(min(Jw_mps / max(k, 1e-10), 20.0))
            Cm = Cf_curr * exp_factor

            if st in {"UF", "MF"}:
                Cp = Cf_curr
                dpi = 0.0
            elif st == "NF" and salt_rejection is not None:
                Cp = Cm * (1.0 - salt_rejection)
                dpi = max(osmotic_pressure_bar(Cm, T_C) - osmotic_pressure_bar(Cp, T_C), 0.0)
            else: # RO
                Cp = (B_lmh * Cm) / max(Jw + B_lmh, 1e-9)
                dpi = max(osmotic_pressure_bar(Cm, T_C) - osmotic_pressure_bar(Cp, T_C), 0.0)
            
            ndp = max(p_local - P_PERM_BAR - dpi, 0.0)
            Jw_new = clamp(A_eff * ndp, 0.0, max_flux)
            Jw = 0.5 * Jw + 0.5 * Jw_new 
        
        dQp = (Jw * area_seg) / 1000.0
        dQp = min(dQp, Qf_curr * 0.9)
        
        salt_p = dQp * Cp
        Qb = Qf_curr - dQp
        salt_in = Qf_curr * Cf_curr
        Cb = (salt_in - salt_p) / max(Qb, 1e-9)

        dP_pa = delta_p_darcy_pa(rho, v, d_h, L_seg, mu)
        dP_bar = pa_to_bar(dP_pa)
        p_next = max(p_local - dP_bar, 0.0)

        total_Qp += dQp
        total_salt_p += salt_p
        sum_Jw += Jw
        sum_ndp += ndp
        sum_dpi += dpi
        
        q_seg_mps = Qf_curr / 3600.0
        hydraulic_W += (ndp * 1e5) * q_seg_mps

        Qf_curr, Cf_curr, p_local = Qb, Cb, p_next
        prev_Jw = Jw

    avg_Jw = sum_Jw / nseg
    avg_ndp = sum_ndp / nseg
    avg_dpi = sum_dpi / nseg
    Qp_final = total_Qp
    Cp_final = total_salt_p / max(Qp_final, 1e-9) if Qp_final > 0 else 0.0

    pump_eff = float(options.get("pump_eff", 0.80))
    pump_kW = (hydraulic_W / max(pump_eff, 1e-6)) / 1000.0
    sec = pump_kW / max(Qp_final, 1e-9)

    return StageResult(
        Qf=Qf_m3h, Cf=Cf_mgL,
        Qp=Qp_final, Cp=Cp_final,
        Qb=Qf_curr, Cb=Cf_curr,
        avg_Jw=avg_Jw, avg_ndp_bar=avg_ndp, avg_delta_pi_bar=avg_dpi,
        p_in_bar=p_in_bar, p_out_bar=p_local, sec_kwhm3=sec
    )

def solve_stage_by_recovery(
    Qf_m3h: float, Cf_mgL: float, T_C: float, elements: int,
    r_target: float, options: Dict[str, Any], stage_type: str = "RO",
) -> StageResult:
    r_target = clamp(r_target, 0.01, 0.90)
    lo, hi = 2.0, 100.0
    best = None
    
    for _ in range(15):
        mid = (lo + hi) / 2
        sr = solve_stage_given_pin(Qf_m3h, Cf_mgL, T_C, elements, mid, options, stage_type)
        rec = sr.Qp / max(Qf_m3h, 1e-9)
        
        if best is None or abs(rec - r_target) < abs((best.Qp/Qf_m3h) - r_target):
            best = sr
            
        if rec > r_target:
            hi = mid
        else:
            lo = mid
            
    return best if best else solve_stage_given_pin(Qf_m3h, Cf_mgL, T_C, elements, 10.0, options, stage_type)

# ============================================================
# HRRO (Closed Circuit / Batch) ÏãúÎÆ¨Î†àÏù¥ÏÖò
# ============================================================

def simulate_HRRO_cycle(
    *,
    C0_mgL: float, V0_m3: float, T_C: float, elements: int,
    p_set_bar: float, recirc_flow_m3h: float, bleed_m3h: float,
    makeup_tds_mgL: float | None, timestep_s: int, max_minutes: float,
    stop_permeate_tds_mgL: float | None, stop_recovery_pct: float | None,
    options: Dict[str, Any],
) -> HRROCycleResult:

    # Î∂ÄÌîº ÏïàÏ†ÑÏû•Ïπò (0.0658 m3 Îì± ÏûëÏùÄ Í∞í ÎåÄÏùë)
    V = V0_m3
    if V < 1e-4: 
        V = elements * 0.02 + 0.05 
    
    M = C0_mgL * V
    dt_h = max(timestep_s, 1) / 3600.0
    t_min = 0.0
    
    Qp_total = 0.0
    salt_p_total = 0.0
    bleed_total = 0.0
    sum_Jw = 0.0
    sum_ndp = 0.0
    sum_dpi = 0.0
    sum_sec_energy = 0.0
    steps = 0
    
    C_makeup = makeup_tds_mgL if makeup_tds_mgL is not None else C0_mgL

    while t_min < max_minutes:
        Cf_loop = M / max(V, 1e-9)
        
        # 1-Step Steady State Solve
        sr = solve_stage_given_pin(
            Qf_m3h=recirc_flow_m3h, # Q_feed = Q_recirc
            Cf_mgL=Cf_loop, T_C=T_C, elements=elements, p_in_bar=p_set_bar,
            options=options, stage_type="RO"
        )
        
        dQp = sr.Qp * dt_h
        dSalt_p = dQp * sr.Cp
        
        dBleed = bleed_m3h * dt_h
        dSalt_bleed = dBleed * Cf_loop 
        
        dMakeup = dQp + dBleed
        dSalt_makeup = dMakeup * C_makeup
        
        M = M - dSalt_p - dSalt_bleed + dSalt_makeup
        
        Qp_total += dQp
        salt_p_total += dSalt_p
        bleed_total += dBleed
        sum_Jw += sr.avg_Jw
        sum_ndp += sr.avg_ndp_bar
        sum_dpi += sr.avg_delta_pi_bar
        sum_sec_energy += sr.sec_kwhm3 * dQp 
        
        steps += 1
        t_min += (dt_h * 60.0)
        
        current_rec = Qp_total / (Qp_total + bleed_total + 1e-9) * 100.0
        if stop_recovery_pct and current_rec >= stop_recovery_pct: break
        if stop_permeate_tds_mgL and sr.Cp >= stop_permeate_tds_mgL: break
            
    Cp_avg = salt_p_total / max(Qp_total, 1e-9) if Qp_total > 0 else 0.0
    avg_sec = sum_sec_energy / max(Qp_total, 1e-9) if Qp_total > 0 else 0.0
    
    return HRROCycleResult(
        minutes=t_min, V_loop_final_m3=V, C_loop_final_mgL=M/V,
        Qp_total_m3=Qp_total, Cp_mix_mgL=Cp_avg, bleed_total_m3=bleed_total,
        recovery_pct=(Qp_total / (Qp_total + bleed_total + 1e-9) * 100.0),
        avg_Jw_lmh=sum_Jw / max(steps, 1),
        avg_ndp_bar=sum_ndp / max(steps, 1),
        avg_delta_pi_bar=sum_dpi / max(steps, 1),
        avg_sec_kwhm3=avg_sec, p_set_bar=p_set_bar
    )

================================================================================
 FILE: hrro.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\services\simulation\solvers\hrro.py
 TYPE: Python Code (Internal)
================================================================================

# app/services/simulation/solver/hrro.py
from typing import Dict, Any
from app.services.simulation.models import HRROCycleResult
# ÏúÑÏóêÏÑú ÎßåÎì† steady_state Î™®ÎìàÏùÑ Ïû¨ÏÇ¨Ïö©Ìï©ÎãàÎã§.
from app.services.simulation.solvers.steady_state import solve_stage_given_pin

def simulate_HRRO_cycle(
    *,
    C0_mgL: float, V0_m3: float, T_C: float, elements: int,
    p_set_bar: float, recirc_flow_m3h: float, bleed_m3h: float,
    makeup_tds_mgL: float | None, timestep_s: int, max_minutes: float,
    stop_permeate_tds_mgL: float | None, stop_recovery_pct: float | None,
    options: Dict[str, Any],
) -> HRROCycleResult:
    """
    [HRRO / CCRO Solver]
    ÏãúÍ∞Ñ Í≤ΩÍ≥º(Time-Stepping)Ïóê Îî∞Î•∏ Closed Circuit Ïö¥Ï†ÑÏùÑ Ìï¥ÏÑùÌï©ÎãàÎã§.
    Batch Í≥µÏ†ïÏù¥ÎØÄÎ°ú Îß§ ÏãúÍ∞Ñ(dt)ÎßàÎã§ Î£®ÌîÑ ÎÇ¥ ÎÜçÎèÑÍ∞Ä Î≥ÄÌï©ÎãàÎã§.
    """
    # 1. Ï¥àÍ∏∞ ÏÉÅÌÉú ÏÑ§Ï†ï
    # Î∂ÄÌîº ÏïàÏ†ÑÏû•Ïπò (V0Í∞Ä ÎÑàÎ¨¥ ÏûëÏúºÎ©¥ ÌååÏù¥Ìïë Îì± Dead Volume ÏûêÎèô Ï∂îÏ†ï)
    V = V0_m3 if V0_m3 > 1e-4 else (elements * 0.02 + 0.05)
    
    M = C0_mgL * V  # Ï¥àÍ∏∞ Ïö©Ïßà ÏßàÎüâ (mg)
    dt_h = max(timestep_s, 1) / 3600.0
    
    # ÎàÑÏ†Å Î≥ÄÏàò Ï¥àÍ∏∞Ìôî
    Qp_total, salt_p_total, bleed_total = 0.0, 0.0, 0.0
    sum_Jw, sum_ndp, sum_dpi, sum_sec = 0.0, 0.0, 0.0, 0.0
    steps = 0
    t_min = 0.0
    
    # Make-up(Î≥¥Ï∂©Ïàò) ÎÜçÎèÑ (ÏóÜÏúºÎ©¥ Ï¥àÍ∏∞ ÎÜçÎèÑÏôÄ ÎèôÏùº Í∞ÄÏ†ï)
    C_makeup = makeup_tds_mgL if makeup_tds_mgL is not None else C0_mgL
    
    # HRRO ÎÇ¥Î∂Ä Îßâ Ï¢ÖÎ•ò (Í∏∞Î≥∏Í∞í RO, NF Îì± Î≥ÄÍ≤Ω Í∞ÄÎä•)
    inner_stage_type = options.get("hrro_membrane_type", "RO")

    # 2. ÏãúÍ∞Ñ Î£®ÌîÑ (Time Stepping)
    while t_min < max_minutes:
        # ÌòÑÏû¨ Î£®ÌîÑ ÎÜçÎèÑ
        Cf_loop = M / max(V, 1e-9)
        
        # [ÌïµÏã¨] ÌòÑÏû¨ ÏàúÍ∞ÑÏùò Î¨ºÎ¶¨Ï†Å ÏÉÅÌÉú Ìï¥ÏÑù (Steady State Solver Ìò∏Ï∂ú)
        # Recirculation FlowÍ∞Ä ÎßâÏùò Feed FlowÍ∞Ä Îê©ÎãàÎã§.
        sr = solve_stage_given_pin(
            Qf_m3h=recirc_flow_m3h, 
            Cf_mgL=Cf_loop, 
            T_C=T_C, 
            elements=elements, 
            p_in_bar=p_set_bar, 
            options=options, 
            stage_type=inner_stage_type
        )
        
        # 3. Î¨ºÏßà ÏàòÏßÄ ÏóÖÎç∞Ïù¥Ìä∏ (dt ÏãúÍ∞Ñ ÎèôÏïà)
        dQp = sr.Qp * dt_h
        dSalt_p = dQp * sr.Cp
        
        dBleed = bleed_m3h * dt_h
        dSalt_bleed = dBleed * Cf_loop 
        
        # Î†àÎ≤® Ï†úÏñ¥ (Level Control): Îπ†Ï†∏ÎÇòÍ∞Ñ ÎßåÌÅº Î≥¥Ï∂©ÏàòÍ∞Ä Îì§Ïñ¥Ïò¥
        # dV = dMakeup - dQp - dBleed = 0  =>  dMakeup = dQp + dBleed
        dMakeup = dQp + dBleed
        dSalt_makeup = dMakeup * C_makeup
        
        # Î£®ÌîÑ ÎÇ¥ ÏßàÎüâ ÏóÖÎç∞Ïù¥Ìä∏
        M = M - dSalt_p - dSalt_bleed + dSalt_makeup
        # Î∂ÄÌîº VÎäî ÏùºÏ†ïÌïòÎã§Í≥† Í∞ÄÏ†ï (Level Control)
        
        # 4. Îç∞Ïù¥ÌÑ∞ ÎàÑÏ†Å
        Qp_total += dQp
        salt_p_total += dSalt_p
        bleed_total += dBleed
        
        sum_Jw += sr.avg_Jw
        sum_ndp += sr.avg_ndp_bar
        sum_dpi += sr.avg_delta_pi_bar
        sum_sec += sr.sec_kwhm3 * dQp # ÏóêÎÑàÏßÄ Ï¥ùÎüâ(kWh) ÎàÑÏ†ÅÏùÑ ÏúÑÌï¥ dQp Í≥±Ìï®
        
        steps += 1
        t_min += (dt_h * 60.0)
        
        # 5. Ï¢ÖÎ£å Ï°∞Í±¥ ÌôïÏù∏ (Batch Ï¢ÖÎ£å)
        current_rec = Qp_total / (Qp_total + bleed_total + 1e-9) * 100.0
        
        # Î™©Ìëú ÌöåÏàòÏú® ÎèÑÎã¨ Ïãú Ï¢ÖÎ£å
        if stop_recovery_pct and current_rec >= stop_recovery_pct: 
            break
        # ÏÉùÏÇ∞Ïàò ÏàòÏßà ÏïÖÌôî Ïãú Ï¢ÖÎ£å
        if stop_permeate_tds_mgL and sr.Cp >= stop_permeate_tds_mgL: 
            break
            
    # 6. ÏµúÏ¢Ö Í≤∞Í≥º Î∞òÌôò
    Cp_avg = salt_p_total / max(Qp_total, 1e-9) if Qp_total > 0 else 0.0
    avg_sec = sum_sec / max(Qp_total, 1e-9) if Qp_total > 0 else 0.0
    
    return HRROCycleResult(
        minutes=t_min, 
        V_loop_final_m3=V, 
        C_loop_final_mgL=M/V,
        Qp_total_m3=Qp_total, 
        Cp_mix_mgL=Cp_avg, 
        bleed_total_m3=bleed_total,
        recovery_pct=(Qp_total / (Qp_total + bleed_total + 1e-9) * 100.0),
        avg_Jw_lmh=sum_Jw/max(steps,1), 
        avg_ndp_bar=sum_ndp/max(steps,1),
        avg_delta_pi_bar=sum_dpi/max(steps,1), 
        avg_sec_kwhm3=avg_sec, 
        p_set_bar=p_set_bar
    )

================================================================================
 FILE: steady_state.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\services\simulation\solvers\steady_state.py
 TYPE: Python Code (Internal)
================================================================================

# app/services/simulation/solvers/steady_state.py
import math
from typing import Dict, Any

from app.services.transport import (
    osmotic_pressure_bar, density_water_kg_m3, viscosity_water_pa_s,
    mass_transfer_k_m_s, delta_p_darcy_pa, pa_to_bar
)
from app.services.simulation.utils import (
    clamp, temp_correct_A, lmh_to_mps, P_PERM_BAR
)
from app.services.simulation.models import StageResult
from app.services.simulation.specs import resolve_membrane_params
from app.services.simulation.strategies import get_transport_strategy

def solve_stage_given_pin(
    Qf_m3h: float,
    Cf_mgL: float,
    T_C: float,
    elements: int,
    p_in_bar: float,
    options: Dict[str, Any],
    stage_type: str = "RO",
) -> StageResult:
    """
    [Steady State Solver]
    Ï£ºÏñ¥ÏßÑ ÏûÖÍµ¨ ÏïïÎ†•(p_in)ÏóêÏÑú Îßâ Î™®ÎìàÏùÑ ÌÜµÍ≥ºÌï† ÎïåÏùò ÏÑ±Îä•ÏùÑ Ìï¥ÏÑùÌï©ÎãàÎã§.
    Ï†ÑÎûµ Ìå®ÌÑ¥ÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ RO/NF/UF/MF Î¨ºÎ¶¨ÏãùÏùÑ ÎèôÏ†ÅÏúºÎ°ú Ï†ÅÏö©Ìï©ÎãàÎã§.
    """
    st_type = (stage_type or "RO").upper()
    strategy = get_transport_strategy(st_type)

    # ÌååÎùºÎØ∏ÌÑ∞ Î°úÎìú
    mem = resolve_membrane_params(options, stage_type=st_type)
    
    if st_type == "NF":
        rej_user = options.get("salt_rejection_pct")
        if rej_user is not None:
            mem["rejection_rate"] = float(rej_user) / 100.0

    # KeyError Î∞©ÏßÄÎ•º ÏúÑÌïú ÏïàÏ†ÑÌïú ÌååÎùºÎØ∏ÌÑ∞ Î°úÎìú (Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï)
    # AÍ∞íÏù¥ÎÇò Î©¥Ï†ÅÏù¥ ÏóÜÏúºÎ©¥ ÏùºÎ∞òÏ†ÅÏù∏ RO Îßâ Ïä§Ìéô(BW30 Í∏â)ÏúºÎ°ú Í∞ÄÏ†ï
    A_ref = float(mem.get("A", 3.0))      # Default: 3.0 LMH/bar
    area_per = float(mem.get("area", 37.0)) # Default: 37.0 m2 (8040 Standard)
    max_flux = float(mem.get("max_flux", 120.0))
    
    # Ï†ÑÎûµÏóêÏÑú ÏÇ¨Ïö©Ìï† BÍ∞íÎèÑ ÏóÜÏúºÎ©¥ 0.0(ÏôÑÏ†Ñ Ï†úÍ±∞)ÏúºÎ°ú ÏÑ§Ï†ïÌï¥Îë†
    if "B_lmh" not in mem:
        mem["B_lmh"] = 0.0

    A_eff = temp_correct_A(A_ref, T_C)
    
    # ÏßÄÏò§Î©îÌä∏Î¶¨
    nseg = int(options.get("segments", 20))
    L_total = float(options.get("channel_length_m", 1.0))
    h_mm = float(options.get("spacer_height_mm", 0.7))
    d_h = float(options.get("hydraulic_d_mm", 2.0 * h_mm)) / 1000.0
    h = h_mm / 1000.0
    
    rho = density_water_kg_m3(T_C)
    mu  = viscosity_water_pa_s(T_C)
    stage_area = elements * area_per
    A_cross = h * (stage_area / (2.0 * L_total))
    
    L_seg = L_total / nseg
    area_seg = stage_area / nseg

    Qf_curr = max(Qf_m3h, 1e-9)
    Cf_curr = max(Cf_mgL, 0.0)
    p_local = p_in_bar

    total_Qp, total_salt_p = 0.0, 0.0
    sum_Jw, sum_ndp, sum_dpi, hydraulic_W = 0.0, 0.0, 0.0, 0.0

    # Ï¥àÍ∏∞ Flux Ï∂îÏ†ï (Ï†ÑÎûµ ÏúÑÏûÑ)
    pi_f = osmotic_pressure_bar(Cf_curr, T_C)
    ndp0 = strategy.get_initial_ndp(p_in_bar, pi_f)
    prev_Jw = clamp(A_eff * ndp0, 0.0, max_flux)

    for _ in range(nseg):
        v = (Qf_curr / 3600.0) / max(A_cross, 1e-9)
        k = mass_transfer_k_m_s(v, d_h, T_C, rho=rho, mu=mu)

        Jw, Cp, dpi = prev_Jw, 0.0, 0.0
        ndp = 0.0
        
        # Î¨ºÎ¶¨Ï†Å ÌèâÌòï ÏÉÅÌÉú Ï∞æÍ∏∞ (Î∞òÎ≥µÎ≤ï)
        for _iter in range(5): 
            Cp, dpi = strategy.calculate_transport(Jw, k, Cf_curr, mem, T_C)
            ndp = max(p_local - P_PERM_BAR - dpi, 0.0)
            Jw_new = clamp(A_eff * ndp, 0.0, max_flux)
            Jw = 0.5 * Jw + 0.5 * Jw_new 
        
        dQp = min((Jw * area_seg) / 1000.0, Qf_curr * 0.95)
        salt_p = dQp * Cp
        Qb = Qf_curr - dQp
        salt_in = Qf_curr * Cf_curr
        Cb = (salt_in - salt_p) / max(Qb, 1e-9)

        dP_pa = delta_p_darcy_pa(rho, v, d_h, L_seg, mu)
        p_next = max(p_local - pa_to_bar(dP_pa), 0.0)

        total_Qp += dQp
        total_salt_p += salt_p
        sum_Jw += Jw
        sum_ndp += ndp
        sum_dpi += dpi
        hydraulic_W += (ndp * 1e5) * (Qf_curr / 3600.0)

        Qf_curr, Cf_curr, p_local = Qb, Cb, p_next
        prev_Jw = Jw

    Qp_final = total_Qp
    Cp_final = total_salt_p / max(Qp_final, 1e-9) if Qp_final > 0 else 0.0
    pump_eff = float(options.get("pump_eff", 0.80))
    sec = (hydraulic_W / max(pump_eff, 1e-6) / 1000.0) / max(Qp_final, 1e-9)

    return StageResult(
        Qf=Qf_m3h, Cf=Cf_mgL, Qp=Qp_final, Cp=Cp_final, Qb=Qf_curr, Cb=Cf_curr,
        avg_Jw=sum_Jw/nseg, avg_ndp_bar=sum_ndp/nseg, avg_delta_pi_bar=sum_dpi/nseg,
        p_in_bar=p_in_bar, p_out_bar=p_local, sec_kwhm3=sec
    )

def solve_stage_by_recovery(
    Qf_m3h: float, Cf_mgL: float, T_C: float, elements: int,
    r_target: float, options: Dict[str, Any], stage_type: str = "RO",
) -> StageResult:
    r_target = clamp(r_target, 0.01, 0.95)
    lo, hi = 1.0, 100.0
    st_upper = (stage_type or "RO").upper()
    if st_upper in ["UF", "MF", "MICROFILTRATION", "ULTRAFILTRATION"]:
        lo, hi = 0.1, 10.0
    
    best = None
    for _ in range(16):
        mid = (lo + hi) / 2
        sr = solve_stage_given_pin(Qf_m3h, Cf_mgL, T_C, elements, mid, options, stage_type)
        rec = sr.Qp / max(Qf_m3h, 1e-9)
        if best is None or abs(rec - r_target) < abs((best.Qp/Qf_m3h) - r_target): best = sr
        if rec > r_target: hi = mid
        else: lo = mid
            
    return best if best else solve_stage_given_pin(Qf_m3h, Cf_mgL, T_C, elements, lo, options, stage_type)

================================================================================
 FILE: specs.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\services\simulation\specs.py
 TYPE: Python Code (Internal)
================================================================================

# app/services/simulation/specs.py
import math
from typing import Dict, Any

from app.services.membranes import get_params_from_options
from app.services.transport import osmotic_pressure_bar
from app.services.simulation.utils import clamp

def calculate_membrane_params(
    flow_gpd: float,
    rej_pct: float,
    area_m2: float,
    test_pressure_bar: float = 15.5,  # ÏóëÏÖÄ Í∏∞Ï§Ä
    test_temp_C: float = 25.0,
    test_tds_mgL: float = 2000.0,
    test_recovery_pct: float = 15.0
) -> Dict[str, float]:
    """
    Ï†úÏ°∞ÏÇ¨ Ïπ¥ÌÉàÎ°úÍ∑∏ Ïä§Ìéô(GPD, Rejection)ÏùÑ Î¨ºÎ¶¨ Î™®Îç∏Ïùò A, B Í≥ÑÏàòÎ°ú Î≥ÄÌôò
    """
    # 1. Îã®ÏúÑ Î≥ÄÌôò
    flow_m3d = flow_gpd * 0.00378541
    flow_lmh = (flow_m3d / 24.0) / max(area_m2, 0.1)
    
    # 2. ÌÖåÏä§Ìä∏ Ï°∞Í±¥ ÏÇºÌà¨Ïïï Ï∂îÏ†ï (Í∞ÑÏù¥ Í≥ÑÏÇ∞ ÎòêÎäî transport Î™®Îìà ÏÇ¨Ïö©)
    cf_log_mean = (math.log(1.0 / (1.0 - test_recovery_pct/100.0)) / (test_recovery_pct/100.0))
    avg_tds = test_tds_mgL * cf_log_mean
    pi_avg = osmotic_pressure_bar(avg_tds, test_temp_C)
    
    # 3. Net Driving Pressure
    ndp = max(test_pressure_bar - pi_avg, 1.0)
    
    # 4. AÍ∞í (Water Permeability) [LMH/bar]
    A_val = flow_lmh / ndp
    
    # 5. BÍ∞í (Salt Permeability) [LMH]
    rej_frac = clamp(rej_pct / 100.0, 0.0, 0.9999)
    B_val = flow_lmh * (1.0 - rej_frac) / max(rej_frac, 0.01)
    
    return {
        "A": A_val,
        "B_lmh": B_val,
        "area": area_m2,
        "max_flux": 120.0 # Default cap
    }

def resolve_membrane_params(options: Dict[str, Any], stage_type: str = "RO") -> Dict[str, Any]:
    """
    options ÎîïÏÖîÎÑàÎ¶¨ÏóêÏÑú A, B Í∞íÏùÑ Ï∞æÍ±∞ÎÇò, ÏóÜÏúºÎ©¥ Ïä§Ìéô Í∏∞Î∞òÏúºÎ°ú Í≥ÑÏÇ∞ÌïòÏó¨ Î∞òÌôò
    """
    # 1. DB/OptionsÏóêÏÑú ÏßÅÏ†ë Î°úÎìú ÏãúÎèÑ
    mem = get_params_from_options(options, stage_type=stage_type)
    
    # 2. AÍ∞íÏù¥ ÏóÜÍ±∞ÎÇò(0.0), ÏÇ¨Ïö©ÏûêÍ∞Ä ÏóëÏÖÄ Ïä§Ìéô ÏûÖÎ†•ÏùÑ ÏõêÌï† Í≤ΩÏö∞
    if options.get("catalog_flow_gpd") and options.get("catalog_rej_pct"):
        calc_params = calculate_membrane_params(
            flow_gpd=float(options["catalog_flow_gpd"]),
            rej_pct=float(options["catalog_rej_pct"]),
            area_m2=float(options.get("catalog_area_m2", mem["area"])),
            test_pressure_bar=float(options.get("test_pressure_bar", 15.5)),
            test_temp_C=float(options.get("test_temp_C", 25.0)),
        )
        mem.update(calc_params)
    
    return mem

================================================================================
 FILE: __init__.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\services\simulation\strategies\__init__.py
 TYPE: Python Code (Internal)
================================================================================

# app/services/simulation/strategies/__init__.py
from app.services.simulation.strategies.base import TransportStrategy
from app.services.simulation.strategies.ro import ROStrategy
from app.services.simulation.strategies.nf import NFStrategy
from app.services.simulation.strategies.uf import UFStrategy
from app.services.simulation.strategies.mf import MFStrategy

def get_transport_strategy(stage_type: str) -> TransportStrategy:
    st = (stage_type or "RO").upper()
    
    if st == "NF":
        return NFStrategy()
    elif st in ["UF", "ULTRAFILTRATION"]:
        return UFStrategy()
    elif st in ["MF", "MICROFILTRATION"]:
        return MFStrategy()
    else:
        return ROStrategy()

__all__ = ["get_transport_strategy", "TransportStrategy"]

================================================================================
 FILE: base.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\services\simulation\strategies\base.py
 TYPE: Python Code (Internal)
================================================================================

# app/services/simulation/strategies/base.py
from abc import ABC, abstractmethod
from typing import Dict, Tuple

class TransportStrategy(ABC):
    """Î™®Îì† Îßâ Î∂ÑÎ¶¨ Î¨ºÎ¶¨ Î™®Îç∏Ïùò Î∂ÄÎ™® ÌÅ¥ÎûòÏä§"""
    
    @abstractmethod
    def calculate_transport(
        self, 
        Jw_lmh: float, 
        k_mps: float, 
        Cf_mgL: float, 
        params: Dict[str, float], 
        T_C: float
    ) -> Tuple[float, float]:
        """
        ÌîåÎü≠Ïä§ÏôÄ Ï°∞Í±¥ÏùÑ Î∞õÏïÑ -> (ÏÉùÏÇ∞Ïàò ÎÜçÎèÑ, ÏÇºÌà¨Ïïï Ï∞®Ïù¥)Î•º Î∞òÌôò
        """
        pass

    @abstractmethod
    def get_initial_ndp(self, p_in_bar: float, pi_feed_bar: float) -> float:
        """Ï¥àÍ∏∞ Ïú†Ìö® Íµ¨Îèô ÏïïÎ†•(NDP) Ï∂îÏ†ï Î°úÏßÅ"""
        pass

================================================================================
 FILE: mf.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\services\simulation\strategies\mf.py
 TYPE: Python Code (Internal)
================================================================================

# app/services/simulation/strategies/mf.py
from typing import Dict, Tuple
from app.services.simulation.utils import P_PERM_BAR
from app.services.simulation.strategies.base import TransportStrategy

class MFStrategy(TransportStrategy):
    """
    [MF] Pore Flow Model
    - Í∞ÄÏû• ÌÅ∞ Í∏∞Í≥µ, Ï†ÄÏïï Ïö¥Ï†Ñ
    - TDS Ï†úÍ±∞Îä• ÏóÜÏùå
    """
    def calculate_transport(self, Jw_lmh: float, k_mps: float, Cf_mgL: float, params: Dict[str, float], T_C: float) -> Tuple[float, float]:
        return Cf_mgL, 0.0

    def get_initial_ndp(self, p_in_bar: float, pi_feed_bar: float) -> float:
        return max(p_in_bar - P_PERM_BAR, 0.0)

================================================================================
 FILE: nf.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\services\simulation\strategies\nf.py
 TYPE: Python Code (Internal)
================================================================================

# app/services/simulation/strategies/nf.py
import math
from typing import Dict, Tuple
from app.services.transport import osmotic_pressure_bar
from app.services.simulation.utils import P_PERM_BAR, lmh_to_mps
from app.services.simulation.strategies.base import TransportStrategy

class NFStrategy(TransportStrategy):
    """
    [NF] Rejection Model
    - ÌÅ¨Í∏∞ Î∞∞Ï†ú + Ï†ÑÌïò Î∞òÎ∞ú
    - Ï†úÍ±∞Ïú®(Rejection Rate)Ïù¥ ÌïµÏã¨ ÌååÎùºÎØ∏ÌÑ∞
    """
    def calculate_transport(self, Jw_lmh: float, k_mps: float, Cf_mgL: float, params: Dict[str, float], T_C: float) -> Tuple[float, float]:
        rej_rate = params.get("rejection_rate", 0.90) # Í∏∞Î≥∏ 90%
        Jw_mps = lmh_to_mps(Jw_lmh)
        
        exp_factor = math.exp(min(Jw_mps / max(k_mps, 1e-10), 10.0))
        Cm = Cf_mgL * exp_factor
        
        # NF ÏàòÏãù: Cp = Cm * (1 - R)
        Cp = Cm * (1.0 - rej_rate)
        
        pi_m = osmotic_pressure_bar(Cm, T_C)
        pi_p = osmotic_pressure_bar(Cp, T_C)
        dpi = max(pi_m - pi_p, 0.0)
        
        return Cp, dpi

    def get_initial_ndp(self, p_in_bar: float, pi_feed_bar: float) -> float:
        return max(p_in_bar - P_PERM_BAR - pi_feed_bar, 0.0)

================================================================================
 FILE: ro.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\services\simulation\strategies\ro.py
 TYPE: Python Code (Internal)
================================================================================

# app/services/simulation/strategies/ro.py
import math
from typing import Dict, Tuple
from app.services.transport import osmotic_pressure_bar
from app.services.simulation.utils import P_PERM_BAR, lmh_to_mps
from app.services.simulation.strategies.base import TransportStrategy

class ROStrategy(TransportStrategy):
    """
    [RO] Solution-Diffusion Model
    - Ïù¥Ïò® Ïö©Ìï¥/ÌôïÏÇ∞ Í∏∞Ï†Ñ
    - BÍ∞í(Salt Permeability)Ïù¥ ÌïµÏã¨ ÌååÎùºÎØ∏ÌÑ∞
    """
    def calculate_transport(self, Jw_lmh: float, k_mps: float, Cf_mgL: float, params: Dict[str, float], T_C: float) -> Tuple[float, float]:
        B_lmh = params.get("B_lmh", 0.0)
        Jw_mps = lmh_to_mps(Jw_lmh)
        
        # ÎÜçÎèÑ Î∂ÑÍ∑π (CP)
        exp_factor = math.exp(min(Jw_mps / max(k_mps, 1e-10), 10.0))
        Cm = Cf_mgL * exp_factor
        
        # RO ÏàòÏãù: Cp = B * Cm / (Jw + B)
        Cp = (B_lmh * Cm) / max(Jw_lmh + B_lmh, 1e-9)
        
        # ÏÇºÌà¨Ïïï Ï∞®Ïù¥ Í≥ÑÏÇ∞
        pi_m = osmotic_pressure_bar(Cm, T_C)
        pi_p = osmotic_pressure_bar(Cp, T_C)
        dpi = max(pi_m - pi_p, 0.0)
        
        return Cp, dpi

    def get_initial_ndp(self, p_in_bar: float, pi_feed_bar: float) -> float:
        # ROÎäî ÏÇºÌà¨ÏïïÏùÑ Í∑πÎ≥µÌï¥Ïïº Ìï®
        return max(p_in_bar - P_PERM_BAR - pi_feed_bar, 0.0)

================================================================================
 FILE: uf.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\services\simulation\strategies\uf.py
 TYPE: Python Code (Internal)
================================================================================

# app/services/simulation/strategies/uf.py
from typing import Dict, Tuple
from app.services.simulation.utils import P_PERM_BAR
from app.services.simulation.strategies.base import TransportStrategy

class UFStrategy(TransportStrategy):
    """
    [UF] Sieving Model
    - TDS(ÏóºÎ∂Ñ) Ï†úÍ±∞Îä• ÏóÜÏùå
    - ÏÇºÌà¨Ïïï ÏòÅÌñ• Î¨¥Ïãú
    """
    def calculate_transport(self, Jw_lmh: float, k_mps: float, Cf_mgL: float, params: Dict[str, float], T_C: float) -> Tuple[float, float]:
        # ÏóºÎ∂Ñ Í∑∏ÎåÄÎ°ú ÌÜµÍ≥º
        return Cf_mgL, 0.0

    def get_initial_ndp(self, p_in_bar: float, pi_feed_bar: float) -> float:
        # ÏÇºÌà¨Ïïï Î¨¥Ïãú, ÏàúÏàò ÏïïÎ†•Ï∞®
        return max(p_in_bar - P_PERM_BAR, 0.0)

================================================================================
 FILE: utils.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\services\simulation\utils.py
 TYPE: Python Code (Internal)
================================================================================

# app/services/simulation/utils.py
from app.services.transport import viscosity_water_pa_s

# ============================================================
# Í∏∞Î≥∏ ÏÉÅÏàò
# ============================================================
R_BAR_L_PER_MOL_K = 0.08314
P_PERM_BAR = 0.0              # Ìà¨Í≥ºÏ∏° Î∞∞Ïïï (Í∞ÄÏ†ï)
DEFAULT_REF_TEMP_C = 25.0     # ÌëúÏ§Ä ÌÖåÏä§Ìä∏ Ïò®ÎèÑ

def clamp(x: float, lo: float, hi: float) -> float:
    return max(lo, min(hi, x))

def temp_correct_A(A_ref: float, temp_C: float, ref_C: float = 25.0) -> float:
    """Ïò®ÎèÑÎ≥¥Ï†ï: Ï†êÎèÑ ÎπÑÏú®Î°ú Î≥¥Ï†ï (Ïò®ÎèÑ ÏÉÅÏäπ -> Ï†êÎèÑ ÌïòÎùΩ -> Ìà¨Í≥ºÏú® Ï¶ùÍ∞Ä)"""
    mu = viscosity_water_pa_s(temp_C)
    mu_ref = viscosity_water_pa_s(ref_C)
    return A_ref * (mu_ref / max(mu, 1e-6))

def mps_to_lmh(J_mps: float) -> float:
    return (J_mps * 1000.0) * 3600.0

def lmh_to_mps(J_lmh: float) -> float:
    return (J_lmh / 1000.0) / 3600.0

================================================================================
 FILE: tasks.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\services\tasks.py
 TYPE: Python Code (Internal)
================================================================================

# ./app/services/tasks.py
from __future__ import annotations

from pathlib import Path
from uuid import UUID
from datetime import datetime, timezone
from loguru import logger
from pydantic import ValidationError
from rq import get_current_job

# PDF/ÌÖúÌîåÎ¶ø
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4
from app.reports.templates.cover import draw_cover
from app.reports.templates.summary import draw_system_summary
from app.reports.templates.stage_metrics import draw_stage_metrics_page  # [ADDED]

# ÏãúÎÆ¨
from app.api.v1.schemas import ScenarioInput
from app.services.simulation import run_l1_simulation

from app.core.config import settings
from app.db.session import SessionLocal
from app.db.models.report_job import ReportJob, ReportStatus

# Í≤ΩÎ°ú Ïú†Ìã∏
from app.core.fs import ensure_dirs, report_output_path

# Îã®ÏúÑ Î≥ÄÌôò (Ï∂úÎ†•Ïö©)
from app.services.units import Units, compute_conversions
from app.services.units_apply_out import (
    to_display_streams, to_display_kpi, to_display_stage_metrics, unit_labels
)


def _derive_pdf_kpi(streams: list[dict], kpi: dict) -> dict:
    """PDF ÌëúÏãúÏö© KPIÏóê permeate/feed Ïú†ÎüâÏùÑ Î≥¥Í∞ï(ÏóÜÏùÑ ÎïåÎßå Í≥ÑÏÇ∞)."""
    kd = dict(kpi or {})
    try:
        if "permeate_m3h" not in kd:
            kd["permeate_m3h"] = sum(
                float(s.get("flow_m3h", 0.0))
                for s in (streams or [])
                if isinstance(s.get("label"), str) and "permeate" in s["label"].lower()
            )
    except Exception:
        pass
    try:
        if "feed_m3h" not in kd:
            feed = next((s for s in (streams or []) if str(s.get("label", "")).lower() == "feed"), None)
            if feed and feed.get("flow_m3h") is not None:
                kd["feed_m3h"] = float(feed["flow_m3h"])
    except Exception:
        pass
    return kd


def task_generate_report(
    payload: dict,
    job_id: str,
    out_units: str | None = None,          # 'display'Î©¥ ÌëúÏãúÎã®ÏúÑÎ°ú Î†åÎçî
    scope_project_id: str | None = None,
    scope_user_id: str | None = None
) -> dict:
    job_uuid = UUID(str(job_id))
    logger.info(f"[job={job_uuid}] report generation start (out_units={out_units}, scope=({scope_project_id},{scope_user_id}))")

    ensure_dirs()  # .data / reports/outputs Ìè¥Îçî Î≥¥Ïû•

    # ÏãúÏûë Ïãú ÏÉÅÌÉú running
    db = SessionLocal()
    try:
        job = db.get(ReportJob, job_uuid)
        if job:
            job.status = ReportStatus.running
            job.started_at = datetime.now(timezone.utc)
            job.error_message = None
            db.add(job)
            db.commit()
        else:
            logger.warning(f"[job={job_uuid}] ReportJob not found at start")
            return {"artifact_path": None}
    finally:
        db.close()

    pdf_path = report_output_path(str(job_uuid))

    try:
        # ÏûÖÎ†• Í≤ÄÏ¶ù + SI ÏãúÎÆ¨Î†àÏù¥ÏÖò
        sim_in = ScenarioInput(**payload)
        sim_out = run_l1_simulation(sim_in)

        # SI Í∏∞Î≥∏Í∞í
        streams = [s.model_dump() for s in sim_out.streams]
        kpi = sim_out.kpi.model_dump()
        stage_metrics = [m.model_dump() for m in (getattr(sim_out, "stage_metrics", None) or [])]
        units = {"flow": "m3/h", "pressure": "bar", "flux": "LMH"}

        # ÌëúÏãú Îã®ÏúÑÎ°ú Ï∂úÎ†•
        if (out_units or "").lower() == "display":
            proj = scope_project_id or getattr(sim_in, "project_id", None)
            user = scope_user_id
            try:
                # ÏõåÏª§ Ïä§ÏΩîÌîÑ Ïú†Îãõ Ï°∞Ìöå
                db = SessionLocal()
                from app.db.models.user_settings import UserSettings
                UserSettings.__table__.create(bind=db.bind, checkfirst=True)
                row = db.query(UserSettings).filter(
                    (UserSettings.project_id == proj) if proj else (UserSettings.project_id.is_(None)),
                    (UserSettings.user_id == user) if user else (UserSettings.user_id.is_(None)),
                ).first()
                if not row:
                    row = UserSettings(project_id=proj, user_id=user)
                    db.add(row)
                    db.commit()
                    db.refresh(row)
                conv = compute_conversions(
                    Units(row.units_flow, row.units_pressure, row.units_temperature, row.units_flux)
                )
            except Exception:
                conv = compute_conversions(Units())  # Ïã§Ìå® Ïãú SI Ïú†ÏßÄ
            finally:
                try:
                    db.close()
                except Exception:
                    pass

            streams = to_display_streams(streams, conv)
            kpi = to_display_kpi(kpi, conv)
            stage_metrics = to_display_stage_metrics(stage_metrics, conv)
            units = unit_labels(conv)

        # PDF KPI Î≥¥Í∞ï
        kpi_pdf = _derive_pdf_kpi(streams, kpi)

        # PDF Î†åÎçî
        c = canvas.Canvas(str(pdf_path), pagesize=A4)
        draw_cover(c, scenario_name=sim_in.scenario_name)
        draw_system_summary(
            c,
            streams=streams,
            kpi=kpi_pdf,
            units=units,
            stage_metrics=stage_metrics,  # <<== ÏöîÏïΩ ÌéòÏù¥ÏßÄ ÌëúÏóê Ï†ÑÎã¨
        )

        # [ADDED] Stage Metrics Ï†ÑÏö© ÌéòÏù¥ÏßÄ(Ìëú + ÎØ∏Îãà Í∑∏ÎûòÌîÑ 3Ï¢Ö)
        if stage_metrics:
            c.showPage()
            draw_stage_metrics_page(c, stage_metrics=stage_metrics, units=units)

        c.save()

        # ÏÑ±Í≥µ: ÏÉÅÎåÄ Í≤ΩÎ°ú Ï†ÄÏû•
        db = SessionLocal()
        try:
            job = db.get(ReportJob, job_uuid)
            if job:
                try:
                    rel = pdf_path.relative_to(Path.cwd())
                except Exception:
                    rel = pdf_path
                job.status = ReportStatus.succeeded
                job.artifact_path = rel.as_posix()
                job.error_message = None
                job.finished_at = datetime.now(timezone.utc)
                db.add(job)
                db.commit()
            else:
                logger.warning(f"[job={job_uuid}] ReportJob not found for update")
        finally:
            db.close()

        return {"artifact_path": str(pdf_path.resolve())}

    except ValidationError as ve:
        logger.error(f"[job={job_uuid}] input validation failed: {ve.errors()}")
        db = SessionLocal()
        try:
            job = db.get(ReportJob, job_uuid)
            if job:
                job.status = ReportStatus.failed
                job.error_message = f"validation: {ve.errors()}"[:500]
                job.finished_at = datetime.now(timezone.utc)
                db.add(job)
                db.commit()
        finally:
            db.close()
        try:
            rq_job = get_current_job()
            if rq_job:
                rq_job.meta = rq_job.meta or {}
                rq_job.meta["error_message"] = f"validation: {ve.errors()}"[:500]
                rq_job.save_meta()
        except Exception:
            logger.exception(f"[job={job_uuid}] failed to save RQ meta")
        raise

    except Exception as e:
        logger.exception(f"[job={job_uuid}] report generation failed: {e}")
        db = SessionLocal()
        try:
            job = db.get(ReportJob, job_uuid)
            if job:
                job.status = ReportStatus.failed
                job.error_message = f"{type(e).__name__}: {e}"[:500]
                job.finished_at = datetime.now(timezone.utc)
                db.add(job)
                db.commit()
        finally:
            db.close()
        try:
            rq_job = get_current_job()
            if rq_job:
                rq_job.meta = rq_job.meta or {}
                rq_job.meta["error_message"] = f"{type(e).__name__}: {e}"[:500]
                rq_job.save_meta()
        except Exception:
            logger.exception(f"[job={job_uuid}] failed to save RQ meta")
        raise


================================================================================
 FILE: transport.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\services\transport.py
 TYPE: Python Code (Internal)
================================================================================

# app/services/transport.py
from __future__ import annotations
import math

# ÏÉÅÏàò
R_BAR_L_PER_MOL_K = 0.08314  # bar¬∑L/(mol¬∑K)                                    # [UNCHANGED]
IONIC_FACTOR = 2.0           # NaCl Î∞òÌä∏Ìò∏ÌîÑ Í≥ÑÏàò i‚âà2                             # [UNCHANGED]
MW_NACL = 58.44              # g/mol                                             # [UNCHANGED]

# ---- Îã®ÏúÑ Î≥ÄÌôò ----
def lmh_to_m_per_s(lmh: float) -> float:
    # 1 LMH = 1e-3 m3/(m2¬∑h) = (1e-3/3600) m/s
    return lmh * (1e-3 / 3600.0)                                                  # [UNCHANGED]

def m_per_s_to_lmh(ms: float) -> float:
    return ms * (3600.0 / 1e-3)                                                   # [UNCHANGED]

def b_mps_to_lmh(b_mps: float) -> float:
    # 1 m/s == 3,600,000 LMH
    return float(b_mps) * 3_600_000.0                                             # [ADDED]

# ---- Î¨ºÏÑ± Í∑ºÏÇ¨ (25¬±10¬∞C Î≤îÏúÑ Í∞ÄÏ†ï) ----
def viscosity_water_pa_s(T_C: float) -> float:
    # Andrade Í∑ºÏÇ¨: Œº[Pa¬∑s]
    T_K = T_C + 273.15
    A, B, C = 2.414e-5, 247.8, 140.0
    return A * 10 ** (B / (T_K - C))                                              # [UNCHANGED]

def density_water_kg_m3(T_C: float) -> float:
    # Îã®Ïàú Í∑ºÏÇ¨
    return 997.0 - 0.3 * (T_C - 25.0)                                             # [UNCHANGED]

def diffusivity_nacl_m2_s(T_C: float) -> float:
    # 25¬∞C ~ 35¬∞C Í∑ºÏÇ¨ (Î¨∏ÌóåÍ∞í 1.5e-9 @25¬∞C)
    return 1.5e-9 * (1.0 + 0.02 * (T_C - 25.0))                                   # [UNCHANGED]

# ---- ÏÇºÌà¨Ïïï (Î∞òÌä∏Ìò∏ÌîÑ, TDS‚ÜíÎ™∞ÎÜçÎèÑ Í∑ºÏÇ¨) ----
def tds_mgL_to_mol_per_L(tds_mgL: float) -> float:
    return (tds_mgL / 1000.0) / MW_NACL                                           # [UNCHANGED]

def osmotic_pressure_bar(tds_mgL: float, T_C: float) -> float:
    C = tds_mgL_to_mol_per_L(tds_mgL)
    T_K = T_C + 273.15
    return IONIC_FACTOR * R_BAR_L_PER_MOL_K * T_K * C                              # [UNCHANGED]

# ---- TCF (Ïò®ÎèÑ Î≥¥Ï†ï) ----
def tcf_A_B(T_C: float, ref_C: float = 25.0) -> float:
    # ArrheniusÌòï Í∞ÑÎã® Î≥¥Ï†ï (Î¨º Ï†êÎèÑ Í∏∞Î∞ò Í∑ºÏÇ¨)
    mu_ref = viscosity_water_pa_s(ref_C)
    mu_now = viscosity_water_pa_s(T_C)
    return mu_ref / mu_now                                                         # [UNCHANGED]

# ---- Sherwood/ÏßàÎüâÏ†ÑÎã¨Í≥ÑÏàò k ----
def reynolds(rho, v, Dh, mu) -> float:
    return rho * v * Dh / mu                                                       # [UNCHANGED]

def schmidt(mu, rho, D) -> float:
    return mu / (rho * D)                                                          # [UNCHANGED]

def sherwood(Re, Sc) -> float:
    # Î≥µÌï© Íµ¨Í∞Ñ: laminar~turbulent ÌòºÌï© Í∑ºÏÇ¨
    if Re < 2100:
        return 0.664 * math.sqrt(Re) * (Sc ** (1/3))
    return 0.023 * (Re ** 0.83) * (Sc ** (1/3))                                    # [UNCHANGED]

def mass_transfer_k_m_s(v: float, Dh: float, T_C: float, rho: float | None = None, mu: float | None = None) -> float:
    _rho = density_water_kg_m3(T_C) if rho is None else rho
    _mu  = viscosity_water_pa_s(T_C) if mu  is None else mu
    D    = diffusivity_nacl_m2_s(T_C)
    Re   = reynolds(_rho, v, Dh, _mu)
    Sc   = schmidt(_mu, _rho, D)
    Sh   = sherwood(Re, Sc)
    return Sh * D / Dh  # [m/s]                                                    # [UNCHANGED]

# ---- CP (film theory) ----
def cp_factor(Jw_lmh: float, k_m_s: float) -> float:
    # C_m = C_b * exp(Jw/k)
    Jw_ms = lmh_to_m_per_s(Jw_lmh)
    return math.exp(max(0.0, Jw_ms / max(k_m_s, 1e-8)))                            # [UNCHANGED]

# ---- ŒîP (Darcy‚ÄìWeisbach Í∑ºÏÇ¨) ----
def friction_factor(Re: float) -> float:
    if Re <= 0:
        return 0.0
    if Re < 2100:
        return 64.0 / Re
    # Blasius Í∑ºÏÇ¨
    return 0.3164 * (Re ** -0.25)                                                  # [UNCHANGED]

def delta_p_darcy_pa(rho: float, v: float, Dh: float, L: float, mu: float) -> float:
    Re = reynolds(rho, v, Dh, mu)
    f  = friction_factor(Re)
    return f * (L / Dh) * 0.5 * rho * v * v                                       # [UNCHANGED]

def pa_to_bar(pa: float) -> float:
    return pa / 1e5                                                                # [UNCHANGED]


================================================================================
 FILE: units.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\services\units.py
 TYPE: Python Code (Internal)
================================================================================

# ./app/services/units.py

from __future__ import annotations
from dataclasses import dataclass

@dataclass
class Units:
    flow: str = "m3/h"       # m3/h | gpm
    pressure: str = "bar"    # bar | psi
    temperature: str = "C"   # C | F
    flux: str = "LMH"        # LMH | gfd

def _lin(scale: float, offset: float = 0.0) -> dict:
    return {"scale": float(scale), "offset": float(offset)}

def compute_conversions(u: Units) -> dict:
    res = {
        "flow":       {"engine": "m3/h"},
        "pressure":   {"engine": "bar"},
        "temperature":{"engine": "C"},
        "flux":       {"engine": "LMH"},
    }
    if (u.flow or "").lower() == "gpm":
        res["flow"].update({"display":"gpm","to_display":_lin(4.402867),"from_display":_lin(1/4.402867)})
    else:
        res["flow"].update({"display":"m3/h","to_display":_lin(1.0),"from_display":_lin(1.0)})

    if (u.pressure or "").lower() == "psi":
        res["pressure"].update({"display":"psi","to_display":_lin(14.5037738),"from_display":_lin(1/14.5037738)})
    else:
        res["pressure"].update({"display":"bar","to_display":_lin(1.0),"from_display":_lin(1.0)})

    if (u.temperature or "").upper() == "F":
        res["temperature"].update({"display":"F","to_display":_lin(9/5,32),"from_display":_lin(5/9,-32*5/9)})
    else:
        res["temperature"].update({"display":"C","to_display":_lin(1.0),"from_display":_lin(1.0)})

    if (u.flux or "").lower() == "gfd":
        res["flux"].update({"display":"gfd","to_display":_lin(0.588579),"from_display":_lin(1/0.588579)})
    else:
        res["flux"].update({"display":"LMH","to_display":_lin(1.0),"from_display":_lin(1.0)})
    return res


================================================================================
 FILE: units_apply_out.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\services\units_apply_out.py
 TYPE: Python Code (Internal)
================================================================================

# ./app/services/units_apply_out.py

from __future__ import annotations
from copy import deepcopy

def _to_display(val, cv: dict):
    if val is None:
        return None
    try:
        return float(val) * float(cv["to_display"]["scale"]) + float(cv["to_display"]["offset"])
    except Exception:
        return val

def to_display_streams(streams: list[dict], conv: dict) -> list[dict]:
    out = []
    for s in streams or []:
        sd = deepcopy(s)
        if "flow_m3h" in sd and "flow" in conv:
            sd["flow_m3h"] = _to_display(sd["flow_m3h"], conv["flow"])
        if "pressure_bar" in sd and "pressure" in conv:
            sd["pressure_bar"] = _to_display(sd["pressure_bar"], conv["pressure"])
        out.append(sd)
    return out

def to_display_kpi(kpi: dict, conv: dict) -> dict:
    kd = deepcopy(kpi or {})
    # flux_lmh -> flux display
    if "flux_lmh" in kd and "flux" in conv:
        kd["flux_lmh"] = _to_display(kd["flux_lmh"], conv["flux"])
    # ndp_bar -> pressure display
    if "ndp_bar" in kd and "pressure" in conv:
        kd["ndp_bar"] = _to_display(kd["ndp_bar"], conv["pressure"])
    # sec_kwhm3, recovery_pct -> Í∑∏ÎåÄÎ°ú
    return kd

# NEW: per-stage metrics Î≥ÄÌôò
def to_display_stage_metrics(rows: list[dict] | None, conv: dict) -> list[dict] | None:
    if not rows:
        return rows
    out = []
    for r in rows:
        rd = deepcopy(r)
        if "pin_bar" in rd and "pressure" in conv:
            rd["pin_bar"] = _to_display(rd["pin_bar"], conv["pressure"])
        if "pout_bar" in rd and "pressure" in conv:
            rd["pout_bar"] = _to_display(rd["pout_bar"], conv["pressure"])
        if "jw_avg_lmh" in rd and "flux" in conv:
            rd["jw_avg_lmh"] = _to_display(rd["jw_avg_lmh"], conv["flux"])
        # sec_kwh_m3 Îäî Í∑∏ÎåÄÎ°ú
        out.append(rd)
    return out

def unit_labels(conv: dict) -> dict:
    """PDF/ÏùëÎãµÏóê ÎçßÎ∂ôÏùº Îã®ÏúÑ ÎùºÎ≤®Îì§"""
    return {
        "flow": conv.get("flow", {}).get("display", "m3/h"),
        "pressure": conv.get("pressure", {}).get("display", "bar"),
        "temperature": conv.get("temperature", {}).get("display", "C"),
        "flux": conv.get("flux", {}).get("display", "LMH"),
    }


================================================================================
 FILE: water_chemistry.py
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\app\services\water_chemistry.py
 TYPE: Python Code (Internal)
================================================================================

# app/services/water_chemistry.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Optional, Dict
import math

# ---------------------------------------------------------
# Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞
# ---------------------------------------------------------

@dataclass
class ChemistryProfile:
    """
    Ìïú ÏßÄÏ†ê(Feed / Stage Brine Îì±)Ïùò ÏàòÏßà ÏÉÅÌÉú.
    - ÎÜçÎèÑ Îã®ÏúÑ: mg/L (Wave UIÏôÄ ÎèôÏùº Í∞êÍ∞Å)
    """
    tds_mgL: float
    temperature_C: float
    ph: float

    alkalinity_mgL_as_CaCO3: Optional[float] = None
    calcium_hardness_mgL_as_CaCO3: Optional[float] = None
    sulfate_mgL: Optional[float] = None
    barium_mgL: Optional[float] = None
    strontium_mgL: Optional[float] = None
    silica_mgL: Optional[float] = None  # as SiO2


# ---------------------------------------------------------
# Î≥¥Ï°∞ Ìï®Ïàò
# ---------------------------------------------------------

def _safe_log10(x: float) -> float:
    return math.log10(max(float(x), 1e-12))


def scale_profile_for_tds(base: ChemistryProfile, new_tds_mgL: float) -> ChemistryProfile:
    """
    TDS ÎπÑÏú®Ïóê Îî∞Îùº Ï£ºÏöî Ïù¥Ïò®(ÏïåÏπºÎ¶¨ÎèÑ, Í≤ΩÎèÑ, Ìô©ÏÇ∞Ïóº, Ba, Sr, SiO2)ÏùÑ ÏÑ†Ìòï Ïä§ÏºÄÏùºÎßÅ.
    - RO ÎÜçÏ∂ï Ïãú "Ï°∞ÏÑ±ÏùÄ Ïú†ÏßÄ, ÎÜçÎèÑÎßå ÎπÑÎ°Ä Ï¶ùÍ∞Ä" Í∞ÄÏ†ïÌïú 1Ï∞® Í∑ºÏÇ¨.
    """
    factor = float(new_tds_mgL) / max(float(base.tds_mgL), 1e-6)

    def _scale(v: Optional[float]) -> Optional[float]:
        return None if v is None else float(v) * factor

    return ChemistryProfile(
        tds_mgL=float(new_tds_mgL),
        temperature_C=base.temperature_C,
        ph=base.ph,  # pH Î≥ÄÌôîÎäî Î≥ÑÎèÑ ÏÇ∞Ï†ïÌïòÏßÄ ÏïäÍ≥† Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ (ÌõÑÏÜç Îã®Í≥ÑÏóêÏÑú Acid dosing Î™®Îç∏ Î∂ôÏùº Ïàò ÏûàÏùå)
        alkalinity_mgL_as_CaCO3=_scale(base.alkalinity_mgL_as_CaCO3),
        calcium_hardness_mgL_as_CaCO3=_scale(base.calcium_hardness_mgL_as_CaCO3),
        sulfate_mgL=_scale(base.sulfate_mgL),
        barium_mgL=_scale(base.barium_mgL),
        strontium_mgL=_scale(base.strontium_mgL),
        silica_mgL=_scale(base.silica_mgL),
    )


# ---------------------------------------------------------
# CaCO3 Í≥ÑÏó¥ (LSI / RSI / S&DSI)
# ---------------------------------------------------------

def _calc_lsi_family(profile: ChemistryProfile) -> Dict[str, Optional[float]]:
    """
    LSI/RSI/S&DSI Í≥ÑÏÇ∞ (APHA Ïä§ÌÉÄÏùº Í≤ΩÌóòÏãù).
    ÌïÑÏöîÌïú Í∞íÏù¥ ÏóÜÏúºÎ©¥ None Î∞òÌôò.
    """
    tds = profile.tds_mgL
    T = profile.temperature_C
    pH = profile.ph
    Alk = profile.alkalinity_mgL_as_CaCO3
    CaH = profile.calcium_hardness_mgL_as_CaCO3

    if any(v is None for v in (tds, T, pH, Alk, CaH)):
        return {"lsi": None, "rsi": None, "s_dsi": None, "caco3_si": None}

    # APHA: pHs = (9.3 + A + B) - (C + D)
    A = (_safe_log10(tds) - 1.0) / 10.0
    B = -13.12 * _safe_log10(T + 273.0) + 34.55
    C = _safe_log10(CaH) - 0.4
    D = _safe_log10(Alk)

    pHs = (9.3 + A + B) - (C + D)
    lsi = pH - pHs
    rsi = 2.0 * pHs - pH
    s_dsi = 2.0 * (pH - pHs)  # simple approximation

    return {
        "lsi": float(lsi),
        "rsi": float(rsi),
        "s_dsi": float(s_dsi),
        "caco3_si": float(lsi),  # Ìé∏ÏùòÏÉÅ CaCO3 SI ‚âí LSI Î°ú Îë†
    }


# ---------------------------------------------------------
# Ìô©ÏÇ∞Ïóº / Ïã§Î¶¨Ïπ¥ Ïä§ÏºÄÏùºÎßÅ (Í∞ÑÎã® IAP/Ksp Í∑ºÏÇ¨)
# ---------------------------------------------------------

# Î™∞ ÏßàÎüâ (g/mol)
_MW_CACO3 = 100.09
_MW_SO4 = 96.06
_MW_Ca = 40.078
_MW_Ba = 137.327
_MW_Sr = 87.62
_MW_SIO2 = 60.0843

# Îã®Ïàú Ïö©Ìï¥ÎèÑ Í∏∞Î∞ò Ksp Í∑ºÏÇ¨(25¬∞C Î∂ÄÍ∑º, ÏóîÏßÄÎãàÏñ¥ÎßÅ Í∞í. ÌïÑÏöî Ïãú Ï°∞Ï†ï)
#   CaSO4¬∑2H2O: S ‚âà 0.015 mol/L ‚Üí Ksp ‚âà S^2
_KSP_CASO4 = (0.015 ** 2)       # ‚âà 2.25e-4
#   SrSO4: S ‚âà 0.012 mol/L
_KSP_SRSO4 = (0.012 ** 2)
#   BaSO4: S ‚âà 1.0e-5 mol/L
_KSP_BASO4 = (1.0e-5 ** 2)

#   Silica: C_sat ‚âà 150 mg/L as SiO2 @25¬∞C ‚Üí Îã®Ïàú ÎÜçÎèÑÎπÑ ÏßÄÏàò
_SIO2_SAT_MGL = 150.0


def _mgL_as_CaCO3_to_Ca_mol_L(hardness_mgL_as_CaCO3: float) -> float:
    """
    Í≤ΩÎèÑ( mg/L as CaCO3 ) ‚Üí Ca2+ mol/L Í∑ºÏÇ¨.
    1 meq/L = 50 mg/L as CaCO3, Ca2+Îäî 2Í∞ÄÏñëÏù¥Ïò®.
    """
    meq_per_L = hardness_mgL_as_CaCO3 / 50.0
    mol_Ca_per_L = (meq_per_L / 2.0) * 1e-3  # 1 meq = 1e-3 eq
    return mol_Ca_per_L


def _mgL_to_mol_L(mgL: float, mw: float) -> float:
    return (mgL / 1000.0) / mw


def _calc_sulfate_family(profile: ChemistryProfile) -> Dict[str, Optional[float]]:
    CaH = profile.calcium_hardness_mgL_as_CaCO3
    SO4 = profile.sulfate_mgL
    Ba = profile.barium_mgL
    Sr = profile.strontium_mgL

    caso4_si = baso4_si = srso4_si = None

    if CaH is not None and SO4 is not None:
        ca_mol = _mgL_as_CaCO3_to_Ca_mol_L(CaH)
        so4_mol = _mgL_to_mol_L(SO4, _MW_SO4)
        iap = ca_mol * so4_mol
        caso4_si = _safe_log10(iap / max(_KSP_CASO4, 1e-20))

    if Ba is not None and SO4 is not None:
        ba_mol = _mgL_to_mol_L(Ba, _MW_Ba)
        so4_mol = _mgL_to_mol_L(SO4, _MW_SO4)
        iap = ba_mol * so4_mol
        baso4_si = _safe_log10(iap / max(_KSP_BASO4, 1e-30))

    if Sr is not None and SO4 is not None:
        sr_mol = _mgL_to_mol_L(Sr, _MW_Sr)
        so4_mol = _mgL_to_mol_L(SO4, _MW_SO4)
        iap = sr_mol * so4_mol
        srso4_si = _safe_log10(iap / max(_KSP_SRSO4, 1e-20))

    return {
        "caso4_si": caso4_si,
        "baso4_si": baso4_si,
        "srso4_si": srso4_si,
    }


def _calc_silica_si(profile: ChemistryProfile) -> Optional[float]:
    if profile.silica_mgL is None or profile.silica_mgL <= 0:
        return None
    return _safe_log10(profile.silica_mgL / _SIO2_SAT_MGL)


# ---------------------------------------------------------
# Ïô∏Î∂ÄÏóê ÎÖ∏Ï∂úÎêòÎäî Î©îÏù∏ Ìï®Ïàò
# ---------------------------------------------------------

def calc_scaling_indices(profile: ChemistryProfile) -> Dict[str, Optional[float]]:
    """
    Ï£ºÏñ¥ÏßÑ ChemistryProfile Ïóê ÎåÄÌï¥ Wave ÏàòÏ§ÄÏùò Ïä§ÏºÄÏùºÎßÅ ÏßÄÌëúÎì§ÏùÑ Í≥ÑÏÇ∞.
    ÏùºÎ∂Ä ÏûÖÎ†•Ïù¥ ÏóÜÏúºÎ©¥ Í¥ÄÎ†® ÏßÄÏàòÎäî None ÏúºÎ°ú ÎÇ®Í∏¥Îã§.
    """
    out: Dict[str, Optional[float]] = {}

    # CaCO3 Í≥ÑÏó¥
    out.update(_calc_lsi_family(profile))

    # Ìô©ÏÇ∞Ïóº Í≥ÑÏó¥
    out.update(_calc_sulfate_family(profile))

    # Silica
    out["sio2_si"] = _calc_silica_si(profile)

    return out


================================================================================
 FILE: run_aquanova.ps1
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\run_aquanova.ps1
 TYPE: Launcher Script
================================================================================

<# ===========================
   AquaNova launcher (Windows/PowerShell) ‚Äî SAFE MODE
   ÌååÏùº: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\run_aquanova.ps1
   Í∏∞Îä•: Î©àÏ∂§ ÌòÑÏÉÅ ÎîîÎ≤ÑÍπÖ Î∞è ÏïàÏ†Ñ Ïã§Ìñâ Î≥¥Ïû•
=========================== #>

param(
  [int]$ApiPort = 8003,
  # [Ï§ëÏöî] Ïô∏Î∂Ä Ï†ëÏÜçÏö© IPÍ∞Ä Î∞îÎÄåÏñ¥ÎèÑ Î°úÏª¨ Ïã§ÌñâÏóî Î¨∏Ï†úÏóÜÎèÑÎ°ù 127.0.0.1ÏùÑ Í∏∞Î≥∏ÏúºÎ°ú Ïû°ÏäµÎãàÎã§.
  [string]$ApiHost = "127.0.0.1", 
  [string]$RedisContainer = "aquanova-redis",
  [string]$RedisUrl = "redis://localhost:6379/0"
)

$ErrorActionPreference = "Stop"
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8

# -------------------------------------------------------------
# 1. Í≤ΩÎ°ú ÏÑ§Ï†ï
# -------------------------------------------------------------
$ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
Set-Location $ScriptDir

Write-Host "=============================================" -ForegroundColor Cyan
Write-Host "   AquaNova Launcher (Starting...)" -ForegroundColor Cyan
Write-Host "=============================================" -ForegroundColor Cyan
Write-Host "[1/6] Setting up paths..."

# venv ÌôïÏù∏
$VenvPython = Join-Path $ScriptDir ".venv\Scripts\python.exe"
if (!(Test-Path $VenvPython)) {
  Write-Host "[ERROR] .venv Ìè¥ÎçîÎÇò python.exeÍ∞Ä ÏóÜÏäµÎãàÎã§: $VenvPython" -ForegroundColor Red
  Write-Host "        Í∞ÄÏÉÅÌôòÍ≤ΩÏùÑ Î®ºÏ†Ä ÏÑ§ÏπòÌï¥Ï£ºÏÑ∏Ïöî."
  Read-Host "Press Enter to exit..."
  exit 1
}

# Ìè¥Îçî ÏÉùÏÑ±
$LogDir  = Join-Path $ScriptDir ".logs"
$DataDir = Join-Path $ScriptDir ".data"
$FontDir = Join-Path $ScriptDir ".assets\fonts"
$RepDir  = Join-Path $ScriptDir "reports\outputs"
@($DataDir, $RepDir, $FontDir, $LogDir) | ForEach-Object {
  if (!(Test-Path $_)) { New-Item -ItemType Directory -Path $_ -Force | Out-Null }
}

# Ìè∞Ìä∏
$FontPath = Join-Path $FontDir "NotoSans-Variable.ttf"
$env:AQUANOVA_FONT_PATH = $FontPath
$env:FONT_PATH = $FontPath
$env:REDIS_URL = $RedisUrl
$env:PYTHONPATH = $ScriptDir

# -------------------------------------------------------------
# 2. Redis Ïã§Ìñâ (ÌÉÄÏûÑÏïÑÏõÉ Î∞©ÏßÄ)
# -------------------------------------------------------------
Write-Host "[2/6] Checking Redis..."
try {
  # [ÏàòÏ†ïÎê®] $dockerInfo Î≥ÄÏàò Í≤ΩÍ≥† Ï†úÍ±∞ -> $nullÎ°ú Ìï†ÎãπÌïòÏó¨ Í≤∞Í≥º Î≤ÑÎ¶º
  $null = docker info 2>&1
  if ($LASTEXITCODE -ne 0) { throw "Docker DesktopÏù¥ Ïã§Ìñâ Ï§ëÏù¥ÏßÄ ÏïäÏäµÎãàÎã§." }

  $state = docker inspect -f '{{.State.Running}}' $RedisContainer 2>$null
  if ($state -eq "true") {
      Write-Host "  - Redis is already running." -ForegroundColor Gray
  } else {
      Write-Host "  - Starting Redis container..."
      docker start $RedisContainer 2>$null | Out-Null
  }
} catch {
  Write-Host "  [WARN] Redis start failed or Docker not ready. (Skipping Redis check)" -ForegroundColor Yellow
  Write-Host "         Error: $_" -ForegroundColor DarkGray
}

# -------------------------------------------------------------
# 3. Î°úÍ∑∏ ÌååÏùº Ï§ÄÎπÑ
# -------------------------------------------------------------
Write-Host "[3/6] Preparing logs..."
$ApiLogOut = Join-Path $LogDir "api.out.log"
$ApiLogErr = Join-Path $LogDir "api.err.log"
$WkrLogOut = Join-Path $LogDir "worker.out.log"
$WkrLogErr = Join-Path $LogDir "worker.err.log"
$UiLogOut  = Join-Path $LogDir "ui.out.log"
$UiLogErr  = Join-Path $LogDir "ui.err.log"

# -------------------------------------------------------------
# 4. ÌîÑÎ°úÏÑ∏Ïä§ Ïã§Ìñâ (API, Worker, UI)
# -------------------------------------------------------------
Write-Host "[4/6] Launching processes..."

# (1) API
$ApiArgs = @('-m','uvicorn','app.main:app','--host',$ApiHost,'--port',$ApiPort,'--reload')
Write-Host "  - Starting API ($ApiHost`:$ApiPort)..." 
$ApiProc = Start-Process -FilePath $VenvPython -ArgumentList $ApiArgs -WorkingDirectory $ScriptDir `
           -WindowStyle Hidden -RedirectStandardOutput $ApiLogOut -RedirectStandardError $ApiLogErr -PassThru
$ApiPid = $ApiProc.Id

# (2) Worker
Write-Host "  - Starting Worker..."
$WkrProc = Start-Process -FilePath $VenvPython -ArgumentList @('-m','app.workers.report_worker') -WorkingDirectory $ScriptDir `
           -WindowStyle Hidden -RedirectStandardOutput $WkrLogOut -RedirectStandardError $WkrLogErr -PassThru
$WkrPid = $WkrProc.Id

# (3) UI (npm) - cmd /c Î°ú Ïã§ÌñâÌïòÏó¨ Î©àÏ∂§ Î∞©ÏßÄ
$UiDir = Join-Path $ScriptDir "ui"
$UiPid = $null
if (Test-Path $UiDir) {
    Write-Host "  - Starting UI (Vite)..."
    # npmÏùÑ ÏßÅÏ†ë Ïã§ÌñâÌïòÎ©¥ Í∞ÄÎÅî Î©àÏ∂îÎØÄÎ°ú cmdÎ•º ÌÜµÌï¥ Ïã§Ìñâ
    $UiProc = Start-Process -FilePath "cmd.exe" -ArgumentList "/c npm run dev" -WorkingDirectory $UiDir `
              -WindowStyle Hidden -RedirectStandardOutput $UiLogOut -RedirectStandardError $UiLogErr -PassThru
    $UiPid = $UiProc.Id
} else {
    Write-Host "  [WARN] UI folder not found." -ForegroundColor Yellow
}

# -------------------------------------------------------------
# 5. PID Ï†ÄÏû•
# -------------------------------------------------------------
Write-Host "[5/6] Saving PID info..."
$PidFile = Join-Path $DataDir "pids.json"
$StatusData = @{
  api = @{ pid = $ApiPid; cmd = "uvicorn" }
  worker = @{ pid = $WkrPid; cmd = "worker" }
  ui = @{ pid = $UiPid; cmd = "npm run dev" }
  started = (Get-Date).ToString("s")
}
$StatusData | ConvertTo-Json -Depth 5 | Set-Content -Encoding UTF8 -Path $PidFile

# -------------------------------------------------------------
# 6. Ìó¨Ïä§ Ï≤¥ÌÅ¨ Î∞è ÎåÄÍ∏∞ (Î©àÏ∂§ ÌòÑÏÉÅÏùò Ï£ºÎ≤î Ìï¥Í≤∞)
# -------------------------------------------------------------
Write-Host "[6/6] Health Check (Waiting 5s)..."
Start-Sleep -Seconds 5

$BaseUrl = "http://${ApiHost}:${ApiPort}"
try {
    # ÌÉÄÏûÑÏïÑÏõÉÏùÑ 2Ï¥àÎ°ú ÏßßÍ≤å Ï£ºÏñ¥ Î¨¥Ìïú ÎåÄÍ∏∞ Î∞©ÏßÄ
    $resp = Invoke-WebRequest "$BaseUrl/health" -UseBasicParsing -TimeoutSec 2 -ErrorAction SilentlyContinue
    if ($resp.StatusCode -eq 200) {
        Write-Host "  [OK] API is ALIVE at $BaseUrl" -ForegroundColor Green
    } else {
        Write-Host "  [WARN] API responded with $($resp.StatusCode)" -ForegroundColor Yellow
    }
} catch {
    Write-Host "  [INFO] API not ready yet (or firewalled). Check logs." -ForegroundColor Gray
}

# -------------------------------------------------------------
# ÏôÑÎ£å
# -------------------------------------------------------------
Write-Host "`n=============================================" -ForegroundColor Cyan
Write-Host "   AquaNova Started! (Running in background)" -ForegroundColor Cyan
Write-Host "=============================================" -ForegroundColor Cyan

Write-Host "Logs:" -ForegroundColor Gray
Write-Host "  Get-Content .\.logs\api.out.log -Wait"

# [Ï§ëÏöî] Ï∞ΩÏù¥ Î∞îÎ°ú Í∫ºÏßÄÏßÄ ÏïäÎèÑÎ°ù ÏÇ¨Ïö©Ïûê ÏûÖÎ†•ÏùÑ Í∏∞Îã§Î¶º
Write-Host "`n(ÏóîÌÑ∞ ÌÇ§Î•º ÎàÑÎ•¥Î©¥ Ïù¥ Ï∞ΩÏù¥ Îã´ÌûôÎãàÎã§... ÌîÑÎ°úÏÑ∏Ïä§Îäî Í≥ÑÏÜç Ïã§ÌñâÎê©ÎãàÎã§)" -ForegroundColor Yellow
Read-Host "Press Enter to exit"

================================================================================
 FILE: package.json
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\ui\package.json
 TYPE: Frontend (UI)
================================================================================

{
  "name": "ui",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "lucide-react": "^0.546.0",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-router-dom": "^7.9.5",
    "reactflow": "^11.11.4",
    "recharts": "^3.3.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.36.0",
    "@tailwindcss/postcss": "^4.1.16",
    "@types/node": "^24.6.0",
    "@types/react": "^19.1.16",
    "@types/react-dom": "^19.1.9",
    "@vitejs/plugin-react": "^5.0.4",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.36.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.22",
    "globals": "^16.4.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.16",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.45.0",
    "vite": "^7.1.7"
  }
}


================================================================================
 FILE: vite.config.js
 PATH: C:\Users\a\Desktop\ÌîÑÎ°úÏ†ùÌä∏\AquaNova\code\ui\vite.config.js
 TYPE: Frontend (UI)
================================================================================


[ERROR reading file]: [Errno 2] No such file or directory: 'C:\\Users\\a\\Desktop\\ÌîÑÎ°úÏ†ùÌä∏\\AquaNova\\code\\ui\\vite.config.js'


# [SKIP] Binary file excluded: python.exe
------------------------------------------------------------
